<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="A free book on modern image optimization techniques. Formats, decoders, techniques for efficient compression and more are covered.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Essential Image Optimization</title>

    <link rel="preload" href="scripts/main.min.js" as="script">
    <link rel="preconnect" href="https://res.cloudinary.com">
    <link rel="preconnect" href="https://www.google-analytics.com">
    <meta name="msapplication-tap-highlight" content="no">
    <link rel="apple-touch-icon" sizes="180x180" href="images/touch/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/touch/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/touch/favicon-16x16.png">
    <link rel="manifest" href="manifest.json">
    <link rel="mask-icon" href="images/touch/safari-pinned-tab.svg" color="#009aff">
    <link rel="shortcut icon" href="images/touch/favicon.ico">
    <meta name="msapplication-config" content="images/touch/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">

    <!-- Your styles -->
    <link rel="stylesheet" href="styles/main.css">

    <!-- Schema.org markup for Google+ -->
    <meta itemprop="name" content="Essential Image Optimization">
    <meta itemprop="description" content="A free book on modern image optimization techniques. Formats, decoders, techniques for efficient compression and more are covered.">
    <meta itemprop="image" content="https://images.guide/images/logo-banner.jpg">

    <!-- Twitter Card data -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@addyosmani">
    <meta name="twitter:title" content="Essential Image Optimization">
    <meta name="twitter:description" content="A free book on modern image optimization techniques. Formats, decoders, techniques for efficient compression and more are covered.">
    <meta name="twitter:creator" content="@addyosmani">
    <!-- Twitter summary card with large image must be at least 280x150px -->
    <meta name="twitter:image" content="https://images.guide/images/logo-banner.jpg">
    <meta name="twitter:image:alt" content="A free book on modern image optimization techniques">

    <!-- Open Graph data -->
    <meta property="og:title" content="summary_large_image">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://images.guide/">
    <meta property="og:image" content="https://images.guide/images/logo-banner.jpg">
    <meta property="og:description" content="A free book on modern image optimization techniques. Formats, decoders, techniques for efficient compression and more are covered.">
    <meta property="fb:admins" content="129712729600">
  </head>
  <body>
    <header>
        <img alt="Essential Image Optimization" class="logo" src="/images/icons/logo.svg"/>
        <div class="credits">
          <div class="author">Книга от <a href="https://twitter.com/addyosmani">Эдди Османи(Addy Osmani)</a></div>
          <div class="reviewers">Большое спасибо:
            <a href="https://twitter.com/kornelski">Корнель Лесински(Kornel Lesi&#x144;ski)<a/>,
            <a href="https://twitter.com/estellevw">Эстель Вайл(Estelle Weyl)</a>,
            <a href="https://twitter.com/malchata">Джереми Вагнер(Jeremy Wagner)</a>,
            <a href="https://twitter.com/tkadlec">Тим Кaдлек(Tim Kadlec)</a>,
            <a href="https://twitter.com/NolanOBrien">Нолан О’Бра́йен(Nolan O’Brien)</a>,
            <a href="https://twitter.com/patmeenan">Патрик Минан (Pat Meenan)</a>,
            <a href="https://twitter.com/kristoferbaxter">Кристофер Бакстер(Kristofer Baxter)</a>,
            <a href="https://twitter.com/HenriHelvetica">Генри Гельветика(Henri Helvetica)</a>,
            <a href="https://twitter.com/hdjirdeh">Хусэйн Джирдэ(Houssein Djirdeh)</a>,
            <a href="https://twitter.com/una">Юна Кравец(Una Kravets)</a>,
            <a href="https://twitter.com/ARebelBelle">Элли Османи(Elle Osmani)</a> and
            <a href="https://twitter.com/igrigorik">Илья Григорик(Ilya Grigorik)</a> за их помощь и ревью.</div>
        </div>
        <a href="https://github.com/addyosmani/essential-image-optimisation" class="github-corner link" aria-label="View source on GitHub">
              <!-- credit: Github Corners - http://tholman.com/github-corners/  -->
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250">
            <path d="M0 0l115 115h15l12 27 108 108V0z" fill="#fff"></path>
            <path class="octo-arm" d="M128 109c-15-9-9-19-9-19 3-7 2-11 2-11-1-7 3-2 3-2 4 5 2 11 2 11-3 10 5 15 9 16" style="-webkit-transform-origin: 130px 106px; transform-origin: 130px 106px"></path>
            <path class="octo-body" d="M115 115s4 2 5 0l14-14c3-2 6-3 8-3-8-11-15-24 2-41 5-5 10-7 16-7 1-2 3-7 12-11 0 0 5 3 7 16 4 2 8 5 12 9s7 8 9 12c14 3 17 7 17 7-4 8-9 11-11 11 0 6-2 11-7 16-16 16-30 10-41 2 0 3-1 7-5 11l-12 11c-1 1 1 5 1 5z"></path>
          </svg>
        </a>
    </header>
    <div class="container">
        <noscript><p>You are viewing this book without JavaScript enabled. Images will be loaded immediately rather than lazy-loaded.</p></noscript>
        <h3 id="-a-id-the-tldr-href-the-tldr-tl-dr-a-"><a id="the-tldr" href="#the-tldr">TL;DR</a></h3>
<p><strong>Мы все должны автоматизировать наш процесс сжатия изображений.</strong></p>
<p>В 2017 году оптимизация изображений должна быть автоматизирована. Так просто забыть внести рекомендации и контент не проходящий через процесс сборки может легко проскочить.
Для автоматизации: используйте <a href="https://github.com/imagemin/imagemin">imagemin</a> или <a href="https://github.com/jcupitt/libvips">libvips</a> для вашего процесса сборки. Существует много альтернатив.</p>
<p>Большинство CDN (например, <a href="https://www.akamai.com/us/en/solutions/why-akamai/image-management.jsp">Akamai</a>) и сторонние решения, такие как <a href="https://cloudinary.com">Cloudinary</a>, <a href="https://imgix.com">imgix</a>, <a href="https://www.fastly.com/io/">Fastly&#39;s Image Optimizer</a>, <a href="https://www.instartlogic.com/technology/machine-learning/smartvision">Instart Logic&#39;s SmartVision</a> или <a href="https://imageoptim.com/api">ImageOptim API</a> предлагают полноценные автоматизированные решения для оптимизации изображений.</p>
<p>Количество времени, которое вы будете тратить на чтение сообщений в блоге и настройки конфигурации больше, чем ежемесячная плата за услуги (у Cloudinary есть <a href="http://cloudinary.com/pricing">бесплатный</a> план). Если вы не хотите передавать эту работу на аутсорсинг по соображениям затрат или задержек, приведённые выше программы с открытым исходным кодом являются надёжными. Такие проекты как <a href="https://github.com/imazen/imageflow">Imageflow</a> или <a href="https://github.com/thumbor/thumbor">Thumbor</a> можно развернуть у себя на хосте.</p>
<p><strong>Все должны эффективно сжимать свои изображения.</strong></p>
<p>Минимум: используйте <a href="https://imageoptim.com/">ImageOptim</a>. Он может значительно уменьшить размер изображений, сохраняя при этом качество. Windows и Linux <a href="https://imageoptim.com/versions.html">альтернативы</a> тоже есть.</p>
<p>Точнее: прогоняйте ваши JPEG&#39;и через <a href="https://github.com/mozilla/mozjpeg">MozJPEG</a> (<code>q=80</code> или ниже отлично подходит для веб-контента) и рассматривайте поддержку <a href="http://cloudinary.com/blog/progressive_jpegs_and_green_martians">Progressive JPEG&#39;а</a>, PNG через <a href="https://pngquant.org/">pngquant</a> и SVG через <a href="https://github.com/svg/svgo">SVGO</a>. Однозначно удаляйте метаданные (<code>--strip</code> для pngquant), чтобы избежать раздутия. Вместо сумасшедше огромных анимированных GIF&#39;ок, поставляйте <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a> видео (или <a href="https://www.webmproject.org/">WebM</a> для Chrome, Firefox и Opera)! Если вы не можете, по крайней мере используйте <a href="https://github.com/pornel/giflossy">Giflossy</a>.
Если вы можете сэкономить дополнительные циклы процессора, нуждаетесь в качестве большем чем в среднем по вебу и не против медленного времени кодирования: попробуйте <a href="https://research.googleblog.com/2017/03/announcing-guetzli-new-open-source-jpeg.html">Guetzli</a>.</p>
<p>Некоторые браузеры заявляют о поддержке форматов изображения через заголовок запроса Accept. Он может использоваться для условной отправки форматов: например, формат с потерями <a href="https://developers.google.com/speed/webp/">WebP</a> для браузеров на основе Blink, таких как Chrome, и фолбэк в виде JPEG/PNG для других браузеров.</p>
<p>Всегда можно сделать больше. Есть инструменты для создания и обслуживания атрибута <code>srcset</code>. Выбор ресурсов может быть автоматизирован в браузерах на основе Blink с <a href="https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints">client-hints</a> и вы можете отправить меньшее количество байт для пользователей, которые выбрали &quot;сохранение данных&quot; в браузере, обратив внимание на <a href="https://developers.google.com/web/updates/2016/02/save-data">Save-Data</a>.</p>
<p>Чем меньше размер файла вы можете сделать для ваших изображений, тем лучше сетевой опыт вы можете предложить своим пользователям, особенно на мобильных устройствах. В этой записи мы рассмотрим способы уменьшения размера изображения с помощью современных методов сжатия с минимальным воздействием на качество.</p>
<details>
<summary><h2>Содержание</h2></summary>
<p>
<ul>
        <li><a href="#introduction">Введение</a></li>
        <li><a href="#do-my-images-need-optimization">Как определить, нужно ли оптимизировать мои изображения?</a></li>
        <li><a href="#choosing-an-image-format">Как выбрать формат изображения?</a></li>
        <li><a href="#the-humble-jpeg">Скромный JPEG</a></li>
        <li><a href="#jpeg-compression-modes">Режимы сжатия JPEG</a>
                <ul>
                        <li><a href="#the-advantages-of-progressive-jpegs">Преимущества Progressive JPEG</a></li>
                        <li><a href="#whos-using-progressive-jpegs-in-production">Кто использует Progressive JPEG в продакшене?</a></li>
                        <li><a href="#the-disadvantages-of-progressive-jpegs">Недостатки Progressive JPEG</a></li>
                        <li><a href="#how-to-create-progressive-jpegs">Как создать Progressive JPEG?</a></li>
                        <li><a href="#chroma-subsampling">Прореживание цветности (или цвета)</a></li>
                        <li><a href="#how-far-have-we-come-from-the-jpeg">Как далеко мы ушли от JPEG?</a></li>
                        <li><a href="#optimizing-jpeg-encoders">Оптимизация JPEG кодировщиков</a></li>
                        <li><a href="#what-is-mozjpeg">Что такое MozJPEG?</a></li>
                        <li><a href="#what-is-guetzli">Что такое Guetzli?</a></li>
                        <li><a href="#mozjpeg-vs-guetzli">Как MozJPEG в сравнении с Guetzli?</a></li>
                        <li><a href="#butteraugli">Butteraugli</a></li>
                </ul>
        </li>
        <li><a href="#what-is-webp">Что такое WebP?</a>
                <ul>
                        <li><a href="#how-does-webp-perform">Какая производительность у WebP?</a></li>
                        <li><a href="#whos-using-webp-in-production">Кто использует WebP в продакшене?</a></li>
                        <li><a href="#how-does-webp-encoding-work">Как работает кодирование WebP?</a></li>
                        <li><a href="#webp-browser-support">Поддержка браузерами WebP</a></li>
                        <li><a href="#how-do-i-convert-to-webp">Как мне конвертировать изображения в WebP?</a></li>
                        <li><a href="#how-do-i-view-webp-on-my-os">Как мне смотреть WebP изображения на моей ОС?</a></li>
                        <li><a href="#how-do-i-serve-webp">Как мне доставлять WebP?</a></li>
                </ul>
        </li>
        <li><a href="#svg-optimization">Оптимизация SVG</a></li>
        <li><a href="#avoid-recompressing-images-lossy-codecs">Избегаем повторного сжатия изображений кодеком с потерями</a></li>
        <li><a href="#reduce-unnecessary-image-decode-costs">Уменьшаем ненужное декодирование изображений и затраты на сжатие</a>
                <ul>
                        <li><a href="#delivering-hidpi-with-srcset">Доставка HiDPI изображений, использую <code>srcset</code></a></li>
                        <li><a href="#art-direction">Художественное направление</a></li>
                </ul>
        </li>
        <li><a href="#color-management">Управление цветом</a></li>
        <li><a href="#image-sprites">Изображения в спрайтах</a></li>
        <li><a href="#lazy-load-non-critical-images">Ленивая загрузка некритичных изображений</a></li>
        <li><a href="#display-none-trap">Избегаем <code>display: none;</code> ловушки</a></li>
        <li><a href="#image-processing-cdns">Имеет ли смысл для вас обработка изображений в CDN?</a></li>
        <li><a href="#caching-image-assets">Кэширование изображений</a></li>
        <li><a href="#preload-critical-image-assets">Предварительная загрузка критически важных изображений</a></li>
        <li><a href="#performance-budgets">Бюджеты производительности для изображений</a></li>
        <li><a href="#closing-recommendations">Заключительные рекомендации</a></li>
        <li><a href="#trivia">Мелочи</a></li>
</ul>
</p>
</details>

<h3 id="-a-id-introduction-href-introduction-a-"><a id="introduction" href="#introduction">Введение</a></h3>
<p><strong>Изображения по-прежнему являются главной причиной раздутия веба.</strong></p>
<p>На изображения приходится значительная часть пропускной способности интернета, потому что файлы изображений часто имеют большие размеры. Согласно <a href="http://httparchive.org/">HTTP Archive</a>, 60% данных, передаваемых для загрузки веб-страницы, - это изображения в формате JPEG, PNG и GIF. По состоянию на июль 2017, изображения составили <a href="http://httparchive.org/interesting.php#bytesperpage">1.7MB</a> загруженного содержимого из 3.0MB среднего сайта.</p>
<p>Согласно Тэмми Эвартс(Tammy Everts), <a href="https://calendar.perfplanet.com/2014/images-are-king-an-image-optimization-checklist-for-everyone-in-your-organization/">доказано</a>, что добавление изображений на страницу или увеличение размера существующих изображений увеличивает конверсию. Маловероятно, что изображения исчезнут и поэтому инвестиции в эффективную стратегию сжатия для минимизации раздутия становятся важны.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image00.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image00.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image00.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image00.jpg"
        alt="Меньшее количество изображений на странице увеличивает конверсию. В среднем 19 изображений на страницу приносят конверсии больше, чем 31 изображение." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image00.jpg"/>
</noscript>
</picture>
<figcaption>Согласно <a href="https://www.thinkwithgoogle.com/marketing-resources/experience-design/mobile-page-speed-load-time/">Soasta/Google research</a> от 2016, изображения были вторым важным средством предсказания конверсии и лучшие страницы имели на 38% меньше изображений.</figcaption>
</figure>

<p>Оптимизация изображений состоит из различных мер, помогающих уменьшить размер файла. В конечном счёте она зависит от требуемого качества изображения.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/image-optimisation"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/image-optimisation"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/image-optimisation" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/image-optimisation"
        alt="Оптимизация изображений состоит из различных мер" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/image-optimisation"/>
</noscript>
</picture>
<figcaption><strong>Оптимизация изображения:</strong> выберите правильный формат, аккуратно сожмите и приоритезируйте важные изображений по сравнению с теми, которые могут быть загружены позже.</figcaption>
</figure>

<p>Распространённые способы оптимизации изображений включают сжатие, отзывчивую загрузку на основе размера экрана, используя <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture"><code>&lt;picture&gt;</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images"><code>&lt;img srcset&gt;</code></a>, и изменение размера для уменьшения стоимости декодирования изображений.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502834117/chart_naedwl.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502834117/chart_naedwl.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502834117/chart_naedwl.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502834117/chart_naedwl.jpg"
        alt="Гистограмма потенциальной экономии изображений от HTTP Archive подтверждает 30KB потенциальной экономии изображений на 95 процентиле." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502834117/chart_naedwl.jpg"/>
</noscript>
</picture>
<figcaption>Согласно <a href="http://jsfiddle.net/rviscomi/rzneberp/embedded/result/">HTTP Archive</a>, экономия на одно изображение на 95 процентиле (смотря на кумулятивную функцию распределения(<em>Cumulative Distribution Function</em>)) 30KB!</strong></figcaption>
</figure>

<p>Большой простор, чтобы всем нам начать оптимизировать изображения лучше.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502519576/essential-image-optimization/image-optim.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502519576/essential-image-optimization/image-optim.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502519576/essential-image-optimization/image-optim.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502519576/essential-image-optimization/image-optim.jpg"
        alt="ImageOptim, используемый на Mac, с рядом изображений, которые были сжаты с экономией более 50%" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502519576/essential-image-optimization/image-optim.jpg"/>
</noscript>
</picture>

<figcaption>ImageOptim является бесплатным, уменьшает размер изображения с помощью современных методов сжатия и зачистки ненужных EXIF мета-данных.
</figcaption>
</figure>

<p>Если вы дизайнер, есть также <a href="https://github.com/ImageOptim/Sketch-plugin">плагин ImageOptim для Sketch</a>, который будет оптимизировать ваши изображения при экспорте. Я считаю это большой экономией времени.</p>
<h3 id="-a-id-do-my-images-need-optimization-href-do-my-images-need-optimization-a-"><a id="do-my-images-need-optimization" href="#do-my-images-need-optimization">Как определить, нужно ли оптимизировать мои изображения?</a></h3>
<p>Выполните аудит сайта с помощью <a href="https://www.webpagetest.org/">WebPageTest.org</a> и он покажет возможности для улучшения оптимизации ваших изображений (смотрите &quot;Compress Images&quot;).</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image1.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image1.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image1.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image1.jpg"
        alt="тест WebPage поддерживает аудит сжатия изображений через раздел сжатие изображений" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image1.jpg"/>
</noscript>
</picture>

<figcaption>Раздел &quot;Compress Images&quot; сайта WebPageTest показывает список изображений, которые можно сжать более эффективно и предполагает сколько сэкономишь на размере файла.
</figcaption>
</figure>


<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image2.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image2.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image2.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image2.jpg"
        alt="рекомендации по сжатию изображений из webpagetest" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image2.jpg"/>
</noscript>
</picture>
</figure>


<p><a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> проверяет лучшие практики производительности. Он включает проверки для оптимизации изображений и может посоветовать изображения, которые могут быть сжаты сильнее или указать изображения, которые вне экрана и могут быть загружены позже.</p>
<p>После выхода Chrome 60, Lighthouse теперь находится в <a href="https://developers.google.com/web/updates/2017/05/devtools-release-notes#lighthouse">панели Audits</a> в Chrome DevTools:</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/hbo.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/hbo.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/hbo.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/hbo.jpg"
        alt="Проверка Lighthouse для HBO.com, отображает рекомендации по оптимизации изображений" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/hbo.jpg"/>
</noscript>
</picture>
<figcaption>Lighthouse может проверять производительность веба, лучшие практики и возможности прогрессивных веб приложений.</figcaption>
</figure>


<p>Вы также можете быть знакомы с другими инструментами аудита производительности, такими как <a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a> или <a href="https://webspeedtest.cloudinary.com/">Website Speed Test</a> от Cloudinary, который включает подробный аудит анализа изображений.</p>
<h2 id="-a-id-choosing-an-image-format-href-choosing-an-image-format-a-"><a id="choosing-an-image-format" href="#choosing-an-image-format">Как выбрать формат изображения?</a></h2>
<p>Как Илья Григорик(Ilya Grigorik) отмечает в своём превосходном <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization">руководстве по оптимизации изображений</a>, «правильный формат» для изображения это сочетание желаемых визуальных результатов и функциональных требований. Вы работаете с растровыми или векторными изображениями?</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502469573/essential-image-optimization/rastervvector.png"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502469573/essential-image-optimization/rastervvector.png"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502469573/essential-image-optimization/rastervvector.png" />

<img
        class="lazyload very-small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502469573/essential-image-optimization/rastervvector.png"
        alt="векторные против растровых изображений"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502469573/essential-image-optimization/rastervvector.png"/>
</noscript>
</picture>
</figure>


<p><a href="https://ru.wikipedia.org/wiki/Растровая_графика">Растровая графика</a> представляет изображения путём кодирования значений каждого пикселя в прямоугольной сетке пикселей. Они не являются независимыми от разрешения или зума. WebP или широко поддерживаемые форматы, такие как JPEG или PNG хорошо подходят для графики где необходим фотореализм. Guetzli, MozJPEG и другие идеи, о которых мы говорили, хорошо применимы к растровой графике.</p>
<p><a href="https://ru.wikipedia.org/wiki/Векторная_графика">Векторная графика</a> использует точки, линии и полигоны для представления изображений и формат используется для простых геометрические фигур (например, логотипов), SVG лучше всего подходит, когда нужно высокое разрешение и масштабирование.</p>
<p>Не тот формат может стоить вам. Логический выбор правильного формата может быть рискован, поэтому экспериментировать с форматами лучше с осторожностью.</p>
<p>Джереми Вагнер(Jeremy Wagner) рассказал про <a href="http://jlwagner.net/talks/these-images/#/2/2">компромиссы</a>, которые стоит учитывать при оценке форматов, в его презентации об оптимизации изображений.</p>
<h2 id="-a-id-the-humble-jpeg-href-the-humble-jpeg-jpeg-a-"><a id="the-humble-jpeg" href="#the-humble-jpeg">Скромный JPEG.</a></h2>
<p><a href="https://ru.wikipedia.org/wiki/JPEG">JPEG</a> может быть самым широко используемым форматом изображений в мире. Как отмечалось ранее, <a href="http://httparchive.org/interesting.php">45% изображений</a> отображаемых на сайтах собранных HTTP Archive это JPEG&#39;и. Ваш телефон, ваш цифровой фотоаппарат, даже старая веб-камера - всё в значительной степени поддерживает этот кодек. Также он очень старый, вернёмся в 1992 год, когда он был впервые выпущен. В это время, было сделано огромное количество исследований, пытаясь улучшить то, что он предлагает.</p>
<p>JPEG-это алгоритм сжатия с потерями, который отбрасывает информацию для экономии места и многих усилий, которые были предприняты после того, как он попытался сохранить визуальную точность, сохраняя при этом размеры файлов как можно меньше.</p>
<p><strong>Какое качество изображения приемлемо в вашем случае?</strong></p>
<p>Форматы, такие как JPEG, лучше всего подходят для фотографий или изображений с несколькими цветовыми областями. Большинство инструментов оптимизации позволит вам установить, каким уровнем сжатия вы довольны; более высокое сжатие уменьшает размер файла, но может привести к артефактам, гало или блочной деградации.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image5.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image5.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image5.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image5.jpg"
        alt="Артефакты сжатия JPEG могут быть в большей степени восприняты по мере перехода от лучшего качества к низкому" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image5.jpg"/>
</noscript>
</picture>
<figcaption>JPEG: Воспринимаемые артефакты сжатия JPEG могут увеличиваться по мере перехода от лучшего качества к низкому. Обратите внимание, что оценки качества изображения в одном инструменте могут сильно отличаться от оценок качества в другом.</figcaption>
</figure>

<p>При выборе какое качество настроить, надо учитывать в какую категорию попадает ваше изображение:</p>
<ul>
<li><strong>Лучшее качество</strong> - когда качество имеет значение больше, чем пропускная способность. Оно может быть, потому что изображение имеет высокое значение в дизайне или отображается в полном разрешении.</li>
<li><strong>Хорошее качество</strong> - когда вы заботитесь о доставке небольшого размера файлов, но не хотите слишком сильно негативно влиять на качество изображения. Пользователи по-прежнему беспокоятся о каком-то уровне качества изображения.</li>
<li><strong>Низкое качество</strong> - когда вы заботитесь о пропускной способности и ухудшение изображения вам подходит. Эти изображения подходят для неоднородных/плохих условий сети.</li>
<li><strong>Низкое качество</strong> - экономия пропускной способности имеет первостепенное значение. Пользователи хотят качественного взаимодействия, но будут согласны на заниженное качество для более быстрой загрузки страниц.</li>
</ul>
<p>Далее поговорим о режимах сжатия JPEG, так как они могут сильно влиять на производительность.</p>
<aside class="note"><b>Заметка:</b> Возможно, мы иногда переоцениваем качество изображения, которое требуется нашим пользователям. Качество изображения можно считать отклонением от идеального несжатого источника. Оно может быть субъективно.</aside>

<h2 id="-a-id-jpeg-compression-modes-href-jpeg-compression-modes-jpeg-a-"><a id="jpeg-compression-modes" href="#jpeg-compression-modes">Режимы сжатия JPEG</a></h2>
<p>У формата изображений JPEG есть множество различных <a href="http://cs.haifa.ac.il/~nimrod/Compression/JPEG/J5mods2007.pdf">режимов сжатия</a>. Три наиболее популярных - это базовый режим сжатия или последовательный JPEG (<em>baseline</em>, он же <em>sequential</em>), Прогрессивный режим сжатия JPEG (прогрессивный JPEG или PJPEG, он же формат с чересстрочной разверткой) и JPEG со сжатием без потерь.</p>
<p><em>Прим. пер.: В дальнейшем слова «режим сжатия» будут опущены, но будут иметься ввиду. Помните, что подразумеваются не какие-то разновидности формата JPEG, а различные режимы (или алгоритмы) обработки содержимого файла. То есть вместо «базовый режим сжатия JPEG», будет «базовый JPEG».</em></p>
<p><strong>Чем отличаются базовый (или последовательный) JPEG и прогрессивный JPEG?</strong></p>
<p>Базовый JPEG (режим по умолчанию в большинстве графических редакторов и инструментов для оптимизации изображений) кодируется и декодируется в относительно простом порядке: сверху вниз. Когда базовый JPEG загружается при медленном или нестабильном соединении, пользователи видят верхнюю часть изображения, которая увеличивается по мере загрузки. JPEG со сжатием без потерь очень похож на базовый, но у него устанавливается меньший коэффициент сжатия.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image6.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image6.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image6.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image6.jpg"
        alt="JPEG с базовым режимом сжатия загружается сверху вниз" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image6.jpg"/>
</noscript>
</picture>
<figcaption>JPEG с базовым режимом сжатия загружается сверху вниз, тогда как прогрессивный режим сжатия JPEG загружает изображение от размытого к более резкому.</figcaption>
</figure>

<p>Прогрессивный JPEG делит изображение на несколько слоёв (<em>scans</em>). Первый слой показывает изображение размытым или с настройками очень низкого качества, а каждые последующие слои улучшают качество изображения. Думайте об этом как о прогрессивном уточнении. У каждого слоя изображения более высокий уровень детализации и, когда они соединяются вместе, получается изображение исходного качества.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image7.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image7.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image7.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image7.jpg"
        alt="Прогрессивный JPEG загружается от низкого разрешения (размытого) к более высокому разрешению" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image7.jpg"/>
</noscript>
</picture>
<figcaption>Базовый JPEG загружает изображение сверху вниз. Прогрессивный JPEG загружается от низкого разрешения (размытого) к более высокому разрешению. Патрик Минан(Pat Meenan) написал <a href="http://www.patrickmeenan.com/progressive/view.php?img=https%3A%2F%2Fwww.nps.gov%2Fplanyourvisit%2Fimages%2FGrandCanyonSunset_960w.jpg">интерактивный инструмент</a> для тестирования и изучения особенностей отображения &quot;слоёв&quot; прогрессивного JPEG.</figcaption>
</figure>

<p>JPEG со сжатием без потерь может быть достигнут путём <a href="http://www.verexif.com/en/">удаления данных EXIF</a>, добавленных цифровыми камерами или графическими редакторами, оптимизацией <a href="https://ru.wikipedia.org/wiki/Код_Хаффмана">таблиц Хаффмана</a> в изображении или повторным сканированием изображения. Такие инструменты как <a href="http://jpegclub.org/jpegtran/">jpegtran</a> позволяют добиться сжатия без потерь за счёт перераспределения сжатых данных, не ухудшая при этом качества изображения. <a href="https://github.com/kud/jpegrescan">jpegrescan</a>, <a href="https://github.com/tjko/jpegoptim">jpegoptim</a> и <a href="https://github.com/mozilla/mozjpeg">mozjpeg</a> (которые мы вскоре рассмотрим) также поддерживают JPEG со сжатием без потерь.</p>
<h3 id="-a-id-the-advantages-of-progressive-jpegs-href-the-advantages-of-progressive-jpegs-jpeg-a-"><a id="the-advantages-of-progressive-jpegs" href="#the-advantages-of-progressive-jpegs">Преимущества прогрессивного JPEG</a></h3>
<p>Способность прогрессивного JPEG показывать «приблизительный предварительный просмотр» изображения при загрузке повышает воспринимаемую производительность: пользователи могут чувствовать, что изображение быстрее загружается по сравнению с адаптивными изображениями.
<em>Прим. пер.: Скорее всего имеется ввиду сравнение с базовым JPEG.</em></p>
<p>При медленном соединении, например 3G, это позволяет пользователю видеть что (примерно) изображено на картинке пока загружена только часть файла и даёт возможность принять решение: ждать его полной загрузки или нет. Это может быть удобнее (и приятнее), чем отображение картинок сверху вниз в случае базового JPEG.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504993129/essential-image-optimization/pjpeg-graph.png"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1504993129/essential-image-optimization/pjpeg-graph.png"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504993129/essential-image-optimization/pjpeg-graph.png" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504993129/essential-image-optimization/pjpeg-graph.png"
        alt="уменьшение времени ожидания за счёт использования прогрессивного JPEG" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504993129/essential-image-optimization/pjpeg-graph.png"/>
</noscript>
</picture>
<figcaption>В 2015, <a href="https://code.facebook.com/posts/857662304298232/faster-photos-in-facebook-for-ios/">Facebook переключился на использование PJPEG (для их iOS приложения)</a> и обнаружил 10% сокращение использования данных. У них появилась возможность показывать качественное изображение на 15% быстрее, чем раньше, оптимизируя предполагаемое время загрузки, как показано на рисунке выше.</figcaption>
</figure>

<p>Прогрессивный JPEG может улучшить сжатие, требуя на <a href="http://www.bookofspeed.com/chapter5.html">2-10%</a> меньше данных по сравнению с базовым/простым JPEG для изображений более 10KB. Более высокое качество сжатия достигается за счёт того, что каждый слой в JPEG изображении может иметь свою собственную выделенную <a href="https://ru.wikipedia.org/wiki/Код_Хаффмана">таблицу Хаффмана</a>. Современные JPEG кодеки (такие как <a href="http://libjpeg-turbo.virtualgl.org/">libjpeg-turbo</a>, MozJPEG и так далее) используют преимущества прогрессивного JPEG для лучшей упаковки данных.</p>
<aside class="note"><b>Примечание:</b> Почему прогрессивный JPEG сжимает лучше? Блоки базового JPEG кодируются за один раз. У прогрессивного JPEG, аналогичные коэффициенты <a href="https://ru.wikipedia.org/wiki/Дискретное_косинусное_преобразование">дискретного косинусного преобразования</a> в более чем одном блоке могут быть обработаны вместе, что приводит к лучшему сжатию</aside>

<h3 id="-a-id-whos-using-progressive-jpegs-in-production-href-whos-using-progressive-jpegs-in-production-jpeg-a-"><a id="whos-using-progressive-jpegs-in-production" href="#whos-using-progressive-jpegs-in-production">Кто использует прогрессивный JPEG в продакшен?</a></h3>
<ul>
<li><a href="https://www.webpagetest.org/performance_optimization.php?test=170717_NQ_1K9P&amp;run=2#compress_images">Twitter.com переключился на использование прогрессивного JPEG</a> с уровнем качества (<em>baseline of quality</em>) 85%. Они измеряли задержку восприятия пользователя (время до первого отображения и общее время загрузки) и пришли к выводу, что прогрессивный JPEG был хорошим выбором с учётом их требований относительно небольшого размера файлов, приемлемого времени кодирования и декодирования.</li>
<li><a href="https://code.facebook.com/posts/857662304298232/faster-photos-in-facebook-for-ios/">Facebook переключился на использование прогрессивного JPEG в приложении для iOS</a>. Они заметили, что это уменьшает объём используемых данных на 15% и позволил им показывать изображение в хорошем качестве на 15% быстрее.</li>
<li><a href="https://engineeringblog.yelp.com/2017/06/making-photos-smaller.html">Yelp переключился на использование прогрессивного JPEG</a> и обнаружил, что отчасти с этим связана экономия объёма хранения изображений примерно на 4.5%. Также они дополнительно сэкономили примерно 13.8% за счёт применения MozJPEG.</li>
</ul>
<p>Множество других сайтов с большим количеством тяжёлых изображений, такие как <a href="https://pinterest.com">Pinterest</a>, также применяют прогрессивный JPEG в продакшен окружении.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1506382472/essential-image-optimization/pinterest-loading.png"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1506382472/essential-image-optimization/pinterest-loading.png"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1506382472/essential-image-optimization/pinterest-loading.png" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1506382472/essential-image-optimization/pinterest-loading.png"
        alt="Все JPEG файлы Pinterest кодируются прогрессивно. Это оптимизирует пользовательский опыт за счёт постепенной загрузки изображений." />
<noscript>
  <img src="http://res.cloudinary.com/ddxwdqwkr/image/upload/v1506382472/essential-image-optimization/pinterest-loading.png
"/>
</noscript>
</picture>
<figcaption>Все JPEG файлы Pinterest кодируются прогрессивно. Это оптимизирует пользовательский опыт за счёт постепенной загрузки изображений.</figcaption>
</figure>

<h3 id="-a-id-the-disadvantages-of-progressive-jpegs-href-the-disadvantages-of-progressive-jpegs-jpeg-a-"><a id="the-disadvantages-of-progressive-jpegs" href="#the-disadvantages-of-progressive-jpegs">Недостатки прогрессивного JPEG</a></h3>
<p>Прогрессивный JPEG может кодироваться медленнее, чем базовый JPEG - иногда в 3 раза дольше. На настольных компьютерах с мощными процессорами это может быть менее затратно, чем на слабых мобильных устройствах с ограниченными ресурсами. Отображение неполных слоёв требует работы, поскольку вы в основном декодируете изображение несколько раз. Эти множественные проходы могут потреблять ресурсы процессора.</p>
<p>Файл JPEG с прогрессивным сжатием также не <em>всегда</em> обладает наименьшим размером. Для очень маленьких изображений (например для миниатюр, иконок) прогрессивный JPEG может быть больше, чем вариант с базовым сжатием. Скорее всего для таких небольших изображений прогрессивное сжатие может не подходить.</p>
<p>Это означает, что при принятии решения о внедрении прогрессивного JPEG вам необходимо провести эксперимент и найти правильный баланс размера файла, задержки в сети и потреблении ресурсов процессора.</p>
<p>Примечание: PJPEG (как и все файлы JPEG) на мобильных устройствах иногда могут обрабатываться аппаратными средствами. Но не у всех Android устройств есть подобные средства, чаще всего они встречаются на дорогих устройствах и устройствах на базе iOS. То есть подобные изображения могут не снизить потребление оперативной памяти увеличив производительность, а наоборот, негативно повлиять на загрузку ЦП и скорость отрисовки в целом.  </p>
<p>Некоторые пользователи могут считать, что прогрессивная загрузка является недостатком, так как может быть трудно определить, когда изображение загрузилось полностью. Поскольку это может сильно различаться для каждой аудитории, оцените, что имеет смысл для вашей аудитории.</p>
<h3 id="-a-id-how-to-create-progressive-jpegs-href-how-to-create-progressive-jpegs-jpeg-a-"><a id="how-to-create-progressive-jpegs" href="#how-to-create-progressive-jpegs">Как создать прогрессивный JPEG?</a></h3>
<p>Инструменты и библиотеки, такие как <a href="https://www.imagemagick.org/">ImageMagick</a>, <a href="http://libjpeg.sourceforge.net/">libjpeg</a>, <a href="http://jpegclub.org/jpegtran/">jpegtran</a>, <a href="https://github.com/danielgtaylor/jpeg-archive">jpeg-recompress</a> и <a href="https://github.com/imagemin/imagemin">imagemin</a> позволяют экспортировать прогрессивный JPEG. Если у вас уже есть существующий процесс оптимизации изображений, скорее всего, что добавление поддержки прогрессивной загрузки может быть достаточно простым:</p>
<pre><code class="lang-js">const gulp = require(&#39;gulp&#39;);
const imagemin = require(&#39;gulp-imagemin&#39;);

gulp.task(&#39;images&#39;, function () {
    return gulp.src(&#39;images/*.jpg&#39;)
        .pipe(imagemin({
            progressive: true
        }))
        .pipe(gulp.dest(&#39;dist&#39;));       
});
</code></pre>
<p>Большинство инструментов для редактирования изображений по умолчанию сохраняют изображения JPEG с базовым режимом сжатия.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_crop,h_477,w_2128,y_0/c_scale,w_500,/v1502426282/essential-image-optimization/photoshop.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_crop,h_477,w_2128,y_0/c_scale,w_900/v1502426282/essential-image-optimization/photoshop.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_crop,h_477,w_2128,y_0/v1502426282/essential-image-optimization/photoshop.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_crop,h_477,w_2128,y_0/v1502426282/essential-image-optimization/photoshop.jpg"
        alt="photoshop поддерживает экспорт в прогрессивный JPEG через меню экспорта файлов" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_crop,h_477,w_2128,y_0/v1502426282/essential-image-optimization/photoshop.jpg"/>
</noscript>
</picture>
<figcaption>Большинство редакторов изображений по умолчанию, сохраняют картинки именно в виде базового JPEG. В Photoshop вы можете сохранить любе изображение как прогрессивный JPEG, выбрав File -&gt; Export -&gt; Save for Web (legacy) и выбрав параметр Progressive. Sketch также поддерживает экспорт в прогрессивный JPEG - export as JPG и отметить пункт  ‘Progressive’ во время сохранения изображения.</figcaption>
</figure>

<h3 id="-a-id-chroma-subsampling-href-chroma-subsampling-a-"><a id="chroma-subsampling" href="#chroma-subsampling">Цветовая субдискретизация</a></h3>
<p>Наши глаза больше склонны к потере деталей цвета в изображении (цветности), чем яркости (luminance или luma, яркость как мера светлоты). <a href="https://ru.wikipedia.org/wiki/Цветовая_субдискретизация">Цветовая субдискретизация</a> (или <a href="https://en.wikipedia.org/wiki/Chroma_subsampling">Chroma subsampling</a>) представляет собой вид сжатия, который снижает точность воспроизведения цвета в сигнале в пользу яркости. Это уменьшает размер файла, в некоторых случаях до <a href="https://calendar.perfplanet.com/2015/why-arent-your-images-using-chroma-subsampling/">15-17%</a>, без отрицательного влияния на качество изображения и может быть использовано в JPEG изображениях. Субдискретизация также может уменьшить потребление памяти изображениями.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503683718/essential-image-optimization/luma-signal.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503683718/essential-image-optimization/luma-signal.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503683718/essential-image-optimization/luma-signal.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503683718/essential-image-optimization/luma-signal.jpg"
        alt="изображение = цвет + яркость (ориг. signal = chroma + luma)" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503683718/essential-image-optimization/luma-signal.jpg"/>
</noscript>
</picture>
</figure>

<p>Контраст образующий формы, которые мы видим на изображении, определяется в первую очередь яркостью. Например, старые или отфильтрованные черно-белые фотографии могут не содержать цвета, но благодаря яркости они могут быть столь же подробными, как и их цветовые контрасты. Цветность (цвет) оказывает меньшее влияние на зрительное восприятие.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503683936/essential-image-optimization/no-subsampling.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503683936/essential-image-optimization/no-subsampling.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503683936/essential-image-optimization/no-subsampling.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503683936/essential-image-optimization/no-subsampling.jpg"
        alt="JPEG поддерживает несколько различных типов субдискретизации: без субдискретизации (none), горизонтальный (horizontal), горизонтальный и вертикальный (horizontal and vertical)" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503683936/essential-image-optimization/no-subsampling.jpg"/>
</noscript>
</picture>
<figcaption>JPEG поддерживает несколько различных типов субдискретизации: без субдискретизации (none), горизонтальный (horizontal), горизонтальный и вертикальный (horizontal and vertical). Эта диаграмма из работы Фредерика Кайзера <a href="http://frdx.free.fr/JPEG_for_the_horseshoe_crabs.pdf">JPEGs for the horseshoe crabs</a></figcaption>
</figure>

<p>Вот несколько общих примеров, обсуждаемых при разговоре о субдискретизации. Обычно говорят  <code>4: 4: 4</code>,<code>4: 2: 2</code> и <code>4: 2: 0</code>. Но что они означают? Предположим, что субдискретизации принимает формат A: B: C. A - количество пикселей в строке, для JPEG - это обычно 4. B представляет количество цветов в первой строке, а C - цвет во второй.</p>
<ul>
<li><code>4:4:4</code> не имеет сжатия, поэтому цвет и яркость передаются без преобразований.</li>
<li><code>4:2:2</code> дискретизация на половину горизонтальной строки, при этом преобразований по вертикали не происходит.</li>
<li><code>4:2:0</code> дискретизация на половину горизонтальной строки, при этом содержимое второй строки игнорируется. (<em>прим. перев. В последней картинке указано что дискретизация происходит на основании первой половины первой и второй строк, т.е. одной половины блока из 8 пикселей</em>)</li>
</ul>
<aside class="note"><b>Примечание:</b> jpegtran и cjpeg поддерживают раздельную настройку качества для яркости и для цветности. Это может быть сделано с помощью флага <code>-sample</code> (например, <code>-sample 2x1</code>).

Вот несколько хороших главных правил:  субдискретизация (<code>-sample 2x2</code>) прекрасна для фотографий. Отсутствие субдискретизации (<code>-sample 1x1</code>) лучше всего подходит для скриншотов, баннеров и кнопок. И как следствие - компромиссный вариант (<code>2x1</code>), когда вы не знаете что использовать.</aside>

<p>Уменьшая количество пикселей в цветовой составляющей изображения, можно значительно уменьшить размер составляющих цвета, и в конечном счёте уменьшить размер файла в байтах.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503684781/essential-image-optimization/subsampling.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503684781/essential-image-optimization/subsampling.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503684781/essential-image-optimization/subsampling.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503684781/essential-image-optimization/subsampling.jpg"
        alt="Настройки цветовой субдискретизации файла JPEG с качеством изображения 80." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503684781/essential-image-optimization/subsampling.jpg"/>
</noscript>
</picture>
<figcaption>Настройки цветовой субдискретизации файла JPEG с качеством изображения 80.</figcaption>
</figure>

<p>Цветовую субдискретизацию стоит рассматривать для большинства типов изображений. Но у этого способа сжатия есть некоторые важные исключения: поскольку подвыборка зависит от того как цвет воспринимается нашими глазами, данный способ не очень подходит для сжатия изображений, где детали цвета могут быть столь же важны, как яркость (например, медицинские изображения).</p>
<p>Изображения, содержащие шрифты, также могут пострадать, поскольку плохое сжатие текста может уменьшить его разборчивость. Более контрастные переходы цвета сложнее сжимать с помощью JPEG, поскольку он был разработан для лучшей обработки фотографических сцен с более мягкими переходами.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503684410/essential-image-optimization/Screen_Shot_2017-08-25_at_11.06.27_AM.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503684410/essential-image-optimization/Screen_Shot_2017-08-25_at_11.06.27_AM.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503684410/essential-image-optimization/Screen_Shot_2017-08-25_at_11.06.27_AM.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503684410/essential-image-optimization/Screen_Shot_2017-08-25_at_11.06.27_AM.jpg"
        alt="Будьте осторожны применяя сильную субдискретизацию к изображениям, содержащим текст." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503684410/essential-image-optimization/Screen_Shot_2017-08-25_at_11.06.27_AM.jpg"/>
</noscript>
</picture>
<figcaption><a href="http://compress-or-die.com/Understanding-JPG/">Understanding JPEG</a> рекомендует придерживаться варианта 4: 4: 4 (1x1) при работе с изображениями, содержащими текст.</figcaption>
</figure>

<p>Общая информация: Точный метод цветовой субдискретизации в спецификации JPEG указан не был, поэтому разные декодеры обрабатывают его по-разному. MozJPEG и libjpeg-turbo используют один и тот же метод обработки. В старых версиях libjpeg используется другой метод, который добавляет кольцевые артефакты (<a href="https://en.wikipedia.org/wiki/Ringing_artifacts">ringing artifacts</a>) в цветах.</p>
<aside class="note"><b>Примечание:</b> Photoshop автоматический выбирает уровень цветовой субдискретизации, когда используется опция ‘Save for web’. Когда уровень качества изображения выставлен в промежутке 51-100, никакой субдискретизации не применяется (<code>4:4:4</code>). Когда уровень качества ниже, применяется сжатие типа <code>4:2:0</code>. Это одна из причин того, что при уменьшении уровня качества с 51 до 50 наблюдается значительное уменьшение размера файла.</aside>

<aside class="note"><b>Примечание:</b> В разговорах о субдискретизации часто упоминается термин <a href="https://en.wikipedia.org/wiki/YCbCr">YCbCr</a>. Это цветовая модель, которая может представлять цветовые пространства <a href="https://en.wikipedia.org/wiki/RGB_color_model">RGB</a> с гамма-коррекцией. Y - яркость с гамма-коррекцией, Cb - компонент цветности синего цвета, а Cr - компонент цветности красного цвета. Если вы посмотрите на ExifData, вы увидите YCbCr рядом с уровнями дискретизации.</aside>

<p>Для дополнительной информации о цветовой субдискретизации, см. <a href="https://calendar.perfplanet.com/2015/why-arent-your-images-using-chroma-subsampling/">Why aren’t your images using Chroma subsampling?</a>.</p>
<h3 id="-a-id-how-far-have-we-come-from-the-jpeg-href-how-far-have-we-come-from-the-jpeg-jpeg-a-"><a id="how-far-have-we-come-from-the-jpeg" href="#how-far-have-we-come-from-the-jpeg">Как далеко мы ушли от JPEG?</a></h3>
<p><strong>Ниже представлены современные форматы изображений в Интернете:</strong></p>
<p><em>tl;dr - большая фрагментация. Нам часто приходится готовить разные форматы изображений для разных браузеров, чтобы иметь возможность использовать что-либо современное.</em></p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/format-comparison.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/format-comparison.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_95/v1502426282/essential-image-optimization/format-comparison.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_95/v1502426282/essential-image-optimization/format-comparison.jpg"
        alt="современный форматы изображений в сравнении по качеству." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_95/v1502426282/essential-image-optimization/format-comparison.jpg"/>
</noscript>
</picture>
<figcaption>Различные современные форматы изображений (и их оптимизаторы) используются для демонстрации того, что можно использовать для достижения размера файла 26 КБ. Мы можем сравнивать качество, используя <a href="https://ru.wikipedia.org/wiki/SSIM">SSIM</a> (структурное сходство) или <a href="https://github.com/google/butteraugli">Butteraugli</a>, о котором мы позже расскажем более подробно.</figcaption>
</figure>

<ul>
<li><strong><a href="https://ru.wikipedia.org/wiki/JPEG_2000">JPEG 2000</a> (2000)</strong> - улучшенный JPEG основанный на отказе от преобразования на основе дискретного косинуса в пользу метода, основанного на вейвлетах. <strong>Поддержка браузерами Safari desktop + iOS</strong></li>
<li><strong><a href="https://ru.wikipedia.org/wiki/JPEG_XR">JPEG XR</a> (2009)</strong> - альтернатива JPEG и JPEG 2000 с поддержкой <a href="http://wikivisually.com/wiki/High_dynamic_range_imaging">HDR</a> и широким <a href="https://ru.wikipedia.org/wiki/Цветовая_модель#Цветовой_охват_моделей_устройств_вывода">охватом</a> (англ. <a href="http://wikivisually.com/wiki/Gamut">gamut</a>) цветовых пространств. Производит файлы меньшего размера, чем JPEG, при немного меньшей скорости кодирования/декодирования. <strong>Поддержка браузерами Edge, IE.</strong></li>
<li><strong><a href="https://ru.wikipedia.org/wiki/WebP">WebP</a> (2010)</strong> - формат от Google, основанный на блочном прогнозе (<a href="http://www.bilsen.com/aic/blockprediction.shtml">block-prediction</a>), с поддержкой сжатия с потерями и без потерь. Оптимизация обычных изображений похожа на JPEG, а изображений с прозрачностью на PNG. Отсутствует настройка цветовой субдискретизации и прогрессивная загрузка. Время декодирования также медленнее, чем декодирование JPEG. <strong>Поддержка браузерами Chrome, Opera. Экспериментальная поддержка в Safari и Firefox.</strong></li>
<li><strong><a href="https://ru.wikipedia.org/wiki/Free_Lossless_Image_Format">FLIF</a> (2015)</strong> - свободный формат сжатия изображений без потери качества, который по степени сжатия превосходит PNG, WebP без сжатия, BPG без сжатия и JPEG 2000 без сжатия. <strong>Поддержки браузерами нет <em>Обратите внимание, что есть <a href="https://github.com/UprootLabs/poly-flif">браузерный JS декодер</a>.</em></strong></li>
<li><strong>HEIF и BPG.</strong> С точки зрения сжатия они одинаковы, но у каждого свой контейнер (wrapper):</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Better_Portable_Graphics">BPG</a> (2015)</strong> - предназначенная для более эффективной с точки зрения сжатия замены JPEG&#39;у, на основе HEVC (<a href="http://wikivisually.com/wiki/High_Efficiency_Video_Coding">High Efficiency Video Coding</a>). Позиционируется, как формат, способный предложить лучший размер файла по сравнению с MozJPEG и WebP. Что маловероятно из-за проблем с лицензированием. <strong>Поддержки браузерами нет. <em>Обратите внимание, что есть <a href="https://bellard.org/bpg/">браузерный JS декодер</a>.</em></strong></li>
<li><strong><a href="https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format">HEIF</a> (2015)</strong> - формат изображений и последовательностей изображений для хранения изображений, кодированных HEVC, с применением ограниченного межкадрового предсказания (в ориг. <a href="https://en.wikipedia.org/wiki/Inter_frame#Inter_frame_prediction">inter-prediction</a>). Apple объявила на WWDC, что они будут изучать переключение на HEIF через JPEG для iOS, ссылаясь на 2x кратную экономию на размере файла. <strong>Поддержки браузерами во время написания книги нет. Со временем в Safari desktop and iOS 11</strong></li>
</ul>
<p>Для более наглядного сравнения вы можете обратиться к <a href="https://people.xiph.org/~xiphmont/demo/daala/update1-tool2b.shtml">этому</a> или <a href="http://xooyoozoo.github.io/yolo-octo-bugfixes/#cologne-cathedral&amp;jpg=s&amp;webp=s">этому</a> сравнению, перечисленных выше форматов.</p>
<p>Таким образом, поддержка браузера фрагментирована, и если вы хотите воспользоваться преимуществами любого из вышеперечисленных форматов, вам, скорее всего, придётся делать копии изображения разных типов для каждого из ваших целевых браузеров. Мы в Google увидели некоторые преимущества в WebP, поэтому в ближайшее время мы займемся им более плотно.</p>
<p>Вы также можете использовать форматы изображений (например, WebP, JPEG 2000) с расширением .jpg (или любым другим), поскольку браузер может отображать изображение, выбирая при этом тип содержимого (media type). Это позволяет согласовать тип содержимого (<a href="https://www.igvita.com/2012/12/18/deploying-new-image-formats-on-the-web/">content-type negotiation</a>) на стороне сервера, чтобы решить, какое изображение отправить, без необходимости правки HTML. Такие сервисы, как Instart Logic, используют этот подход при доставке изображений своим клиентам.</p>
<p>А сейчас, давайте поговорим о том случае, когда вы не можете готовить разные форматы изображений для разных браузеров, об <strong>оптимизации кодировщиков JPEG</strong>.</p>
<h3 id="-a-id-optimizing-jpeg-encoders-href-optimizing-jpeg-encoders-jpeg-a-"><a id="optimizing-jpeg-encoders" href="#optimizing-jpeg-encoders">Оптимизация кодировщиков JPEG</a></h3>
<p>Современные кодировщики JPEG пытаются создавать более мелкие файлы с высоким качеством воспроизведения, поддерживая совместимость с существующими браузерами и приложениями для обработки изображений. Они избегают необходимости вводить новые форматы изображений или изменения в экосистеме, чтобы повысить эффективность сжатия. Два таких кодировщика - MozJPEG и Guetzli.</p>
<p><strong><em>tl;dr Какой оптимизирующий кодировщик JPEG вы должны использовать?</em></strong></p>
<ul>
<li>Большинство задач: MozJPEG</li>
<li>Качество - это ваша главная проблема, и вы не возражаете против долгого времени кодирования: используйте Guetzli</li>
<li>Если вам нужна возможность настройки:<ul>
<li><a href="https://github.com/danielgtaylor/jpeg-archive">JPEGRecompress</a> (который под капотом использует MozJPEG)</li>
<li><a href="http://www.jpegmini.com/">JPEGMini</a>. Он похож на Guetzli - автоматически выбирает лучшее качество. Он не настолько сложен, как Guetzli, но он быстрее и нацелен на качество сжатия, более подходящее для Интернета.</li>
<li><a href="https://imageoptim.com/api">ImageOptim API</a> (с бесплатным онлайн <a href="https://imageoptim.com/online">интерфейсом</a>) - он уникален в обработке цвета. Вы можете выбрать качество цвета отдельно от общего качества. Он автоматически выбирает уровень цветовой субдискретизации для сохранения цветов с высоким разрешением в скриншотах, но избегает ненужных байтов на плавных переходах цветах на естественных фотографиях.</li>
</ul>
</li>
</ul>
<h3 id="-a-id-what-is-mozjpeg-href-what-is-mozjpeg-mozjpeg-a-"><a id="what-is-mozjpeg" href="#what-is-mozjpeg">Что такое MozJPEG?</a></h3>
<p>Mozilla предлагает модернизированный кодировщик JPEG под названием <a href="https://github.com/mozilla/mozjpeg">MozJPEG</a>. <a href="https://research.mozilla.org/2014/03/05/introducing-the-mozjpeg-project/">Утверждается</a>, что сжатие эффективнее до 10% от обычного сжатия в JPEG. Файлы, сжатые с помощью MozJPEG, работают кроссбраузерно, а некоторые из его функций включают в себя оптимизацию прогрессивного режима сжатия, <a href="https://ru.wikipedia.org/wiki/Треллис-квантование">треллис-квантование</a>  (англ. <a href="https://en.wikipedia.org/wiki/Trellis_quantization">trellis quantization</a>) (отбрасывание деталей, которые сжимаются хуже), и несколько достойных пресетов таблицы квантования, которые помогают создавать более плавные изображения с высоким разрешением (также это возможно и в ImageMagick, если вы захотите пробиваться через его XML-конфигурации).</p>
<p>MozJPEG поддерживается как в ImageOptim, так и в imagemin, плагине для ImageOptim. Этот плагин относительно надёжен и довольно просто настраивается. Вот пример реализации с Gulp:</p>
<pre><code class="lang-js">const gulp = require(&#39;gulp&#39;);
const imagemin = require(&#39;gulp-imagemin&#39;);
const imageminMozjpeg = require(&#39;imagemin-mozjpeg&#39;);

gulp.task(&#39;mozjpeg&#39;, () =&gt;
    gulp.src(&#39;src/*.jpg&#39;)
    .pipe(imagemin([imageminMozjpeg({
        quality: 85
    })]))
    .pipe(gulp.dest(&#39;dist&#39;))
);
</code></pre>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image10.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image10.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image10.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image10.jpg"
        alt="mozjpeg запущенный в коммандной строке" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image10.jpg"/>
</noscript>
</picture>
</figure>


<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image11.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image11.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image11.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image11.jpg"
        alt="Сжатие mozjpeg с различным качеством. С качеством q=90, 841KB. С качеством  q=85, 562KB. С качеством  q=75, 324KB. При этом оценки Butteraugli и SSIM становятся немного хуже, поскольку мы понижаем качество." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image11.jpg"/>
</noscript>
</picture>
<figcaption>MozJPEG: сравнение размеров файлов и визуального сходства с разными установками качества.</figcaption>
</figure>


<p>Я использовал <a href="https://github.com/imagemin/imagemin-jpeg-recompress">jpeg-compress</a> из проекта <a href="https://github.com/danielgtaylor/jpeg-archive">jpeg-archive</a> для расчёта степени SSIM (структурного сходства) с исходным изображением. SSIM представляет собой метод измерения сходства между двумя изображениями, где степень SSIM является мерой качества одного изображения, относительно второго, «идеального» изображения.</p>
<p>По моему опыту, MozJPEG - хороший вариант для сжатия изображений для Интернета с высоким качеством изображения при одновременном сокращении размера файла. В случае небольших и средних файлов я обнаружил, что MozJPEG (при качестве = 80-85) обеспечил 30-40% экономии на размере файла при сохранении приемлемого SSIM, с 5-6% улучшением в режиме jpeg-turbo. Но он повышает <a href="http://www.libjpeg-turbo.org/About/Mozjpeg">затраты на кодирование</a>, по сравнению с исходным JPEG, так что его преимущества не будут для вас актуальны.</p>
<aside class="note"><b>Примечание:</b> если вам нужен инструмент, поддерживающий MozJPEG с дополнительной возможностью настройки и некоторые бесплатные утилиты для сравнения изображений, посмотрите в сторону <a href="https://github.com/danielgtaylor/jpeg-archive">jpeg-recompress</a>. Джереми Вагнер, автор Web Performance in Action, с успехом использовал его с <a href="https://twitter.com/malchata/status/884836650563579904">этой</a> конфигурацией.</aside>

<h3 id="-a-id-what-is-guetzli-href-what-is-guetzli-guetzli-a-"><a id="what-is-guetzli" href="#what-is-guetzli">Что такое Guetzli?</a></h3>
<p><a href="https://github.com/google/guetzli">Guetzli</a> это многообещающий, хотя и медленный, JPEG-кодировщик от Google, который пытается найти самый маленький JPEG, который на глаз неотличим от оригинала. Он выполняет последовательность экспериментов, которые делают предложение для окончательного JPEG, учитывающего психовизуальную ошибку каждого предположения. Из них он выбирает вариант с наивысшим баллом в качестве конечного результата.</p>
<p>Чтобы измерить различия между изображениями, Guetzli использует <a href="https://github.com/google/butteraugli">Butteraugli</a>, модель для измерения разности изображений, основанной на восприятии человека (см. ниже). Guetzli может принять во внимание несколько свойств зрения, в отличие от других кодировщиков JPEG. Например, существует связь между количеством видимого зелёного света и восприятием синего, поэтому изменения в синем рядом с зелёным могут быть закодированы не так точно.</p>
<aside class="note"><b>Примечание:</b> Размер файла изображения <strong>намного</strong> больше зависит от выбора <strong>качества</strong>, а не <strong>кодека</strong>. Есть гораздо большие различия в размерах файлов между JPEG самого низкого качества по сжатию экономией достигнутой за счёт смены кодировщика. Использование самого низкого приемлемого качества очень важно. Избегайте не обдуманного выставления сжатия на самое высокое качество.</aside>

<p>Guetzli <a href="https://research.googleblog.com/2017/03/announcing-guetzli-new-open-source-jpeg.html">утверждает</a>, что он достигает 20-30 процентного сокращения размера изображений для заданного Butteraugli по сравнению с другими кодировщиками. Основным минусом Guetzli является то, что он чрезвычайно, очень медленный и в настоящее время подходит только для статического контента. Из README мы можем отметить, что для Guetzli требуется большой объем памяти - это может занять 1 минуту + 200 МБ оперативной памяти на мегапиксель. В этом <a href="https://github.com/google/guetzli/issues/50">обсуждении на GitHub</a> описано применение Guetzli на практике. Он может быть идеальным, когда вы оптимизируете изображения в процессе сборки статического сайта, но не в случае выполнения в режиме реального времени.</p>
<aside class="note"><b>Примечание:</b> Guetzli может быть более подходящим, когда вы оптимизируете изображения в процессе сборки статического сайта или ситуации, когда оптимизация изображения не выполняется в режиме реального времени.</aside>

<p>Инструменты, такие как ImageOptim поддерживают оптимизацию Guetzli (в <a href="https://imageoptim.com/">самой последней версии</a>).</p>
<pre><code class="lang-js">const gulp = require(&#39;gulp&#39;);
const imagemin = require(&#39;gulp-imagemin&#39;);
const imageminGuetzli = require(&#39;imagemin-guetzli&#39;);

gulp.task(&#39;guetzli&#39;, () =&gt;
    gulp.src(&#39;src/*.jpg&#39;)
    .pipe(imagemin([
        imageminGuetzli({
            quality: 85
        })
    ]))
    .pipe(gulp.dest(&#39;dist&#39;))

);
</code></pre>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image12.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image12.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image12.jpg" />

<img
        class="small lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image12.jpg"
        alt="guetzli запущенный через gulp для оптимизации" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image12.jpg"/>
</noscript>
</picture>
</figure>

<p>Потребовалось почти семь минут (при высокой загрузке процессора) для кодирования трёх 3MP изображений с использованием Guetzli с различными режимами сжатия. Думаю, что этот вариант более ценен для архивирования фотографий с более высоким разрешением.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image13.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image13.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image13.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image13.jpg"
        alt="Сравнение guetzli при разных уровнях качества. q=100, 945KB. q=90, 687KB. q=85, 542KB." />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image13.jpg"/>
</noscript>
</picture>
<figcaption>Guetzli: Сравнение размеров файлов и оценок визуального сходства с различными уровнями сжатия.</figcaption>
</figure>


<aside class="note"><b>Примечание:</b> Рекомендуется запускать Guetzli на высококачественных изображениях (например, несжатые входные изображения, источники PNG или JPEG со 100% качеством или около того). Он будет работать и на других изображениях (например, JPEG с качеством 84 или ниже), но результаты могут быть хуже.</aside>

<p>Хотя сжатие изображения с помощью Guetzli занимает очень (очень) много времени и заставляет ваши кулеры шуметь, в случае больших изображений оно того стоит. У меня было несколько случаев, где он сохранял до 40% размера файла при сохранении визуальной точности. Это делает его идеальным для архивирования фотографий. На изображениях малого и среднего размера наблюдалась некоторая экономия размера (в диапазоне 10-15 КБ), и она не была ярко выражена. Guetzli при сжатии может искажать (добавлять волноподобные искажения) мелкие изображения .</p>
<p>Вам также может быть интересно исследование Эрика Портиса(Eric Portis), <a href="https://cloudinary.com/blog/a_closer_look_at_guetzli">сравнивающего</a> Guetzli с автоматическим сжатием Cloudinary для другой точки зрения об эффективности алгоритма.</p>
<h3 id="-a-id-mozjpeg-vs-guetzli-href-mozjpeg-vs-guetzli-mozjpeg-guetzli-a-"><a id="mozjpeg-vs-guetzli" href="#mozjpeg-vs-guetzli">MozJPEG в сравнении с Guetzli</a></h3>
<p>Сравнение разных кодировщиков JPEG сложная задача - нужно сравнить качество и точность соответствия сжатого изображения оригиналу, а также конечный размер. Как отмечает эксперт по сжатию изображений Корнель Лесински(Kornel Lesi&#x144;ski), сравнительный анализ одного, но не всех этих аспектов может привести к <a href="https://kornel.ski/faircomparison">неверным</a> выводам.</p>
<p>Как же Guetzli сравнить с MozJPEG? - Корнель считает что:</p>
<ul>
<li>Guetzli ориентирован на высококачественные изображения (butteraugli говорит, что на качество <code>q=90</code>+, MozJPEG же лучше работает при качестве <code>q=75</code>)</li>
<li>Guetzli намного медленнее при сжатии (оба генерируют стандартный JPEG, так что декодирование выполняется как обычно)</li>
<li>MozJPEG не устанавливает настройки качества автоматически, но вы можете подобрать параметры с помощью сторонних инструментов, например <a href="https://github.com/danielgtaylor/jpeg-archive">jpeg-archive</a></li>
</ul>
<p>Существует ряд методов для определения, являются ли сжатые изображения визуально или воспринимаемо, похожими на их источники. Исследования качества изображения часто используют такие методы, как <a href="https://ru.wikipedia.org/wiki/SSIM">SSIM</a> (структурное сходство). Однако Guetzli оптимизирован для Butteraugli.</p>
<h3 id="-a-id-butteraugli-href-butteraugli-butteraugli-a-"><a id="butteraugli" href="#butteraugli">Butteraugli</a></h3>
<p><a href="https://github.com/google/butteraugli">Butteraugli</a> - это проект Google, который оценивает тот момент, когда человек может заметить визуальное ухудшение (психовизуальное сходство) среди двух изображений. Он даёт оценку для едва заметных различий. Butteraugli не только даёт скалярную оценку, но и вычисляет пространственную карту уровня различий. Т.е. SSIM определяет совокупность ошибок в изображении и на этом основании ставит оценку, Butteraugli оценивает по худшей области изображения.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image14.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image14.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_95/v1502426282/essential-image-optimization/Modern-Image14.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_95/v1502426282/essential-image-optimization/Modern-Image14.jpg"
        alt="butteraugli при оценке изображения попугаев" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_95/v1502426282/essential-image-optimization/Modern-Image14.jpg"/>
</noscript>
</picture>
<figcaption>Выше приведён пример, в котором для определения минимального порога качества JPEG использовался Butteraugli. Сжатие проводился до тех пор, пока ухудшение качества изображения не распознавалось пользователем. Сжатие привело к 65 процентному уменьшению общего размера файла.</figcaption>
</figure>

<p>На практике вы определяете целевой уровень визуального качества, а затем выполняете несколько различных стратегий оптимизации изображений, глядя на оценки Butteraugli, прежде чем выбрать то, что соответствует лучшему балансу размера файла и уровня.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image15.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image15.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image15.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image15.jpg"
        alt="butteraugli, запущенный из коммандной строки" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image15.jpg"/>
</noscript>
</picture>
<figcaption>В общем, мне потребовалось около 30 минут, чтобы локально настроить Butteraugli после установки Bazel и получить сборку из исходных кодов на C++ для правильной компиляции на моем Mac. Работа с ним довольно проста: укажите два изображения для сравнения (исходная и сжатая версия), и это даст вам оценку качества сжатого изображения.</figcaption>
</figure>

<p><strong>Что отличает Butteraugli от других способов сравнения визуального сходства?</strong></p>
<p><a href="https://github.com/google/guetzli/issues/10#issuecomment-276295265">Этот комментарий</a> от участника проекта Guetzli предполагает, что Guetzli лучше всего при сравнении с помощью Butteraugli и хуже всего на SSIM, тогда как оценки MozJPEG одинаковы в обоих тестах. Это соответствует исследованию, на основании которого я составил свою собственную стратегию оптимизации изображений. Я использую Butteraugli и Node модуль вроде <a href="https://www.npmjs.com/package/img-ssim">img-ssim</a>, которым даю сжатые изображения, и они сравниваю исходное изображение с их оценками SSIM до/после Guetzli и MozJPEG.</p>
<p><strong>Можно ли комбинировать кодировщики?</strong></p>
<p>Для больших изображений я обнаружил, что сочетание Guetzli <strong>со сжатием без потерь</strong> и MozJPEG (с использованием jpegtran, а не cjpeg, чтобы избежать отбрасывания работы, сделанной Guetzli), может привести к дополнительному уменьшению размера файла на 10-15% (всего 55%) с очень незначительными сокращениями по SSIM. Этот вариант требует анализа, и я бы поостерёгся использовать его в работе, но он был опробован другими специалистами, например <a href="ariya.io/2017/03/squeezing-jpeg-images-with-guetzli">Ария Хидаят(Ariya Hidayat)</a>, и их исследования показали перспективы данного варианта.</p>
<p>MozJPEG - удобный для новичков кодировщик веб-ресурсов, относительно быстрый и создающий на выходе качественные изображения. Поскольку Guetzli является ресурсоёмким и работает лучше всего на больших высококачественных изображениях, я бы его оставил более продвинутым пользователям.</p>
<h2 id="-a-id-what-is-webp-href-what-is-webp-what-is-webp-a-"><a id="what-is-webp" href="#what-is-webp">What is WebP?</a></h2>
<p><a href="https://developers.google.com/speed/webp/">WebP</a> is a recent image format from Google aiming to offer lower file-sizes for lossless and lossy compression at an acceptable visual quality. It includes support for alpha-channel transparency and animation.</p>
<p>In the last year, WebP gained a few percent over compression-wise in lossy and lossless  modes and speed-wise the algorithm got twice as fast with a 10% improvement in decompression.  WebP is not a tool for all purposes, but it has some standing and a growing user base in the image compression community. Let’s examine why.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image16.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image16.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image16.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image16.jpg"
        alt="comparison of webp at different quality settings. q=90, 646KB. q=80= 290KB. q=75, 219KB. q=70, 199KB" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/Modern-Image16.jpg"/>
</noscript>
</picture>
<figcaption>WebP: A comparison of file sizes and visual similarity scores at different qualities.</figcaption>
</figure>

<h3 id="-a-id-how-does-webp-perform-href-how-does-webp-perform-how-does-webp-perform-a-"><a id="how-does-webp-perform" href="#how-does-webp-perform">How does WebP perform?</a></h3>
<p><strong>Lossy Compression</strong></p>
<p>WebP lossy files, using a VP8 or VP9 video key frame encoding variant, are on average cited by the WebP team as being <a href="https://developers.google.com/speed/webp/docs/webp_study">25-34%</a> smaller than JPEG files.</p>
<p>In the low-quality range (0-50), WebP has a large advantage over JPEG because it can blur away ugly blockiness artifacts. A medium quality setting (-m 4 -q 75) is the default balancing speed/file-size. In the higher-range (80-99), the advantages of WebP shrink. WebP is recommended where speed matters more than quality.</p>
<p><strong>Lossless Compression</strong></p>
<p><a href="https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study">WebP lossless files are 26% smaller than PNG files</a>. The lossless load-time decrease compared to PNG is 3%. That said, you generally don’t want to deliver your users lossless on the web. There’s a difference between lossless and sharp edges (e.g. non-JPEG). Lossless WebP may be more suitable for archival content.</p>
<p><strong>Transparency</strong></p>
<p>WebP has a lossless 8-bit transparency channel with only 22% more bytes than PNG. It also supports lossy RGB transparency, which is a feature unique to WebP.</p>
<p><strong>Metadata</strong></p>
<p>The WebP file format supports EXIF photo metadata and XMP digital document metadata. It also contains an ICC Color Profile.</p>
<p>WebP offers better compression at the cost of being more CPU intensive. Back in 2013, the compression speed of WebP was ~10× slower than JPEG but is now negligible (some images may be 2× slower). For static images that are processed as part of your build, this shouldn’t be a large issue. Dynamically generated images will likely cause a perceivable CPU overhead and will be something you will need to evaluate.</p>
<aside class="note"><b>Note:</b> WebP lossy quality settings are not directly comparable to JPEG. A JPEG at ‘70% quality’ will be quite different to a WebP image at ‘70% quality’ because WebP achieves smaller file sizes by discarding more data.</aside>

<h3 id="-a-id-whos-using-webp-in-production-href-whos-using-webp-in-production-who-s-using-webp-in-production-a-"><a id="whos-using-webp-in-production" href="#whos-using-webp-in-production">Who’s using WebP in production?</a></h3>
<p>Many large companies are using WebP in production to reduce costs and decrease web page load times.</p>
<p>Google reported 30-35% savings using WebP over other lossy compression schemes, serving 43 billion image requests a day, 26% of that being lossless compression. That’s a lot of requests and significant savings. Savings would undoubtedly be larger if <a href="http://caniuse.com/#search=webp">browser support</a> were better and more widespread. Google also uses it in production sites like Google Play and YouTube.</p>
<p>Netflix, Amazon, Quora, Yahoo, Walmart, Ebay, The Guardian, Fortune, and USA Today, all compress and serve images with WebP for browsers which support it. VoxMedia <a href="https://product.voxmedia.com/2015/8/13/9143805/performance-update-2-electric-boogaloo">shaved 1-3s off load times</a> for The Verge by switching over to WebP for their Chrome users. <a href="https://iso.500px.com/500px-color-profiles-file-formats-and-you/">500px</a> saw an average 25% reduction in image file size with similar or better image quality when switching to serving it to their Chrome users.</p>
<p>There are quite a few more companies on board than this sample list indicates.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/webp-conversion.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/webp-conversion.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/webp-conversion.jpg" />

<img
        class="small lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/webp-conversion.jpg"
        alt="WebP stats at Google: over 43B image requests a day" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/webp-conversion.jpg"/>
</noscript>
</picture>
<figcaption>WebP usage at Google: 43 billion WebP image requests a day are served across YouTube, Google Play, Chrome Data Saver and G+.</figcaption>
</figure>

<h3 id="-a-id-how-does-webp-encoding-work-href-how-does-webp-encoding-work-how-does-webp-encoding-work-a-"><a id="how-does-webp-encoding-work" href="#how-does-webp-encoding-work">How does WebP encoding work?</a></h3>
<p>WebP’s lossy encoding is designed to compete with JPEG for still images. There are three key phases to WebP’s lossy encoding:</p>
<p><strong>Macro-blocking</strong> – splitting an image into 16×16 (macro) blocks of luma pixels and two 8×8 blocks of chroma pixels. This may sound familiar to the idea of JPEGs doing color space conversion, chroma channel downsampling and image subdivision.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image18.png"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image18.png"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image18.png" />

<img
        class="small lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image18.png"
        alt="Macro-blocking example of a Google Doodle where we break a range of pixels down into luma and chroma blocks."/>
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image18.png"/>
</noscript>
</picture>

</figure>

<p><strong>Prediction</strong> – every 4×4 subblock of a macroblock has a prediction model applied that effectively does filtering. This defines two sets of pixels around a block – A (the row directly above it) and L (the column to the left of it). Using these two the encoder fills a test block with 4×4 pixels and determines which creates values closest to the original block. Colt McAnlis talks about this in more depth in <a href="https://medium.com/@duhroach/how-webp-works-lossly-mode-33bd2b1d0670">How WebP lossy mode works</a>.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image19.png"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image19.png"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image19.png" />

<img
        class="lazyload very-small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image19.png"
        alt="Google Doodle example of a segment displaying the row, target block and column L when considering a prediction model."/>
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image19.png"/>
</noscript>
</picture>

</figure>

<p>A Discrete Cosine Transform (DCT) is applied with a few steps similar to JPEG encoding. A key difference is use of an <a href="https://www.youtube.com/watch?v=FdMoL3PzmSA&amp;index=7&amp;list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H">Arithmetic Compressor</a> vs JPEG’s Huffman.</p>
<p>If you want to dive deeper, Google Developer’s article <a href="https://developers.google.com/speed/webp/docs/compression">WebP Compression Techniques</a> goes into this topic in depth.</p>
<h3 id="-a-id-webp-browser-support-href-webp-browser-support-webp-browser-support-a-"><a id="webp-browser-support" href="#webp-browser-support">WebP browser support</a></h3>
<p>Not all browsers support WebP, however <a href="http://caniuse.com/webp">according to CanIUse.com</a>, global user support is at about 74%. Chrome and Opera natively support it. Safari, Edge, and Firefox have experimented with it but not landed it yet in official releases. This often leaves the task of getting the WebP image to the user up to the web developer. More on this later.</p>
<p>Here are the major browsers and support information for each:</p>
<ul>
<li>Chrome: Chrome began full support at version 23.</li>
<li>Chrome for Android: Since Chrome 50</li>
<li>Android: Since Android 4.2</li>
<li>Opera: Since 12.1</li>
<li>Opera Mini: All versions</li>
<li>Firefox: Some beta support</li>
<li>Edge: Some beta support</li>
<li>Internet Explorer: No support</li>
<li>Safari: Some beta support</li>
</ul>
<p>WebP is not without its downsides. It lacks full-resolution color space options and does not support progressive decoding. That said, tooling for WebP is decent and browser-support, while limited to Chrome and Opera at the time of writing, may well cover enough of your users for it to be worth considering with a fallback.</p>
<h3 id="-a-id-how-do-i-convert-to-webp-href-how-do-i-convert-to-webp-how-do-i-convert-my-images-to-webp-a-"><a id="how-do-i-convert-to-webp" href="#how-do-i-convert-to-webp">How do I convert my images to WebP?</a></h3>
<p>Several commercial and open source image editing and processing packages support WebP. One particularly useful application is XnConvert: a free, cross-platform, batch image processing converter.</p>
<aside class="note"><b>Note:</b> It’s important to avoid converting low or average quality JPEGs to WebP. This is a common mistake and can generate WebP images with JPEG compression artifacts. This can lead to WebP being less efficient as it has to save the image <em>and</em> the distortions added by JPEG, leading to you losing on quality twice. Feed conversion apps the best quality source file available, preferably the original.</aside>

<p><strong><a href="http://www.xnview.com/en/xnconvert/">XnConvert</a></strong></p>
<p>XnConvert enables batch image processing, compatible with over 500 image formats. You can combine over 80 separate actions to transform or edit your images in multiple ways.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image20.png"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image20.png"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image20.png" />

<img
        class="small lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image20.png"
        alt="XNConvert app on Mac where a number of images have been converted to WebP"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image20.png"/>
</noscript>
</picture>
<figcaption>XnConvert supports batch image optimisation, allowing straight-forward conversion from source files to WebP and other formats. In addition to compression, XnConvert can also help with metadata stripping, cropping, color depth customisation and other transforms.</figcaption>
</figure>

<p>Some of the options listed on the xnview website include:</p>
<ul>
<li>Metadata: Editing</li>
<li>Transforms: Rotate, Crop, Resize</li>
<li>Adjustments: Brightness, Contrast, Saturation</li>
<li>Filters: Blur, Emboss, Sharpen</li>
<li>Effects: Masking, Watermark, Vignetting</li>
</ul>
<p>The results of your operations can be exported to about 70 different file formats, including WebP. XnConvert is free for Linux, Mac, and Windows. XnConvert is highly recommended, especially for small businesses.</p>
<p><strong>Node modules</strong></p>
<p><a href="https://github.com/imagemin/imagemin">Imagemin</a> is a popular image minification module that also has an add-on for converting images to WebP (<a href="https://github.com/imagemin/imagemin-webp">imagemin-webp</a>). This supports both lossy and lossless modes.</p>
<p>To install imagemin and imagemin-webp run:</p>
<pre><code>&gt; npm install --save imagemin imagemin-webp
</code></pre><p>We can then require() in both modules and run them over any images (e.g. JPEGs) in a project directory. Below we’re using lossy encoding with a WebP encoder quality of 60:</p>
<pre><code class="lang-js">const imagemin = require(&#39;imagemin&#39;);
const imageminWebp = require(&#39;imagemin-webp&#39;);

imagemin([&#39;images/*.{jpg}&#39;], &#39;images&#39;, {
    use: [
        imageminWebp({quality: 60})
    ]
}).then(() =&gt; {
    console.log(‘Images optimized’);
});
</code></pre>
<p>Similar to JPEGs, it’s possible to notice compression artefacts in our output. Evaluate what quality setting makes sense for your own images. Imagemin-webp can also be used to encode lossless quality WebP images (supporting 24-bit color and full transparency) by passing <code>lossless: true</code> to options:</p>
<pre><code class="lang-js">const imagemin = require(&#39;imagemin&#39;);
const imageminWebp = require(&#39;imagemin-webp&#39;);

imagemin([&#39;images/*.{jpg,png}&#39;], &#39;build/images&#39;, {
    use: [
        imageminWebp({lossless: true})
    ]
}).then(() =&gt; {
    console.log(‘Images optimized’);
});
</code></pre>
<p>A <a href="https://github.com/sindresorhus/gulp-webp">WebP plugin for Gulp</a> by Sindre Sorhus built on imagemin-webp and a <a href="https://www.npmjs.com/package/webp-loader">WebP loader for WebPack</a> are also available. The Gulp plugin accepts any options the imagemin add-on does:</p>
<pre><code class="lang-js">const gulp = require(&#39;gulp&#39;);
const webp = require(&#39;gulp-webp&#39;);

gulp.task(&#39;webp&#39;, () =&gt;
    gulp.src(&#39;src/*.jpg&#39;)
    .pipe(webp({
        quality: 80,
        preset: &#39;photo&#39;,
        method: 6
    }))
    .pipe(gulp.dest(&#39;dist&#39;))
);
</code></pre>
<p>Or lossless:</p>
<pre><code class="lang-js">const gulp = require(&#39;gulp&#39;);
const webp = require(&#39;gulp-webp&#39;);

gulp.task(&#39;webp-lossless&#39;, () =&gt;
    gulp.src(&#39;src/*.jpg&#39;)
    .pipe(webp({
        lossless: true
    }))
    .pipe(gulp.dest(&#39;dist&#39;))
);
</code></pre>
<p><strong>Batch image optimization using Bash</strong></p>
<p>XNConvert supports batch image compression, but if you would prefer to avoid using an app or a build system, bash and image optimization binaries keep things fairly simple.</p>
<p>You can bulk convert your images to WebP using <a href="https://developers.google.com/speed/webp/docs/cwebp">cwebp</a>:</p>
<pre><code>find ./ -type f -name &#39;*.jpg&#39; -exec cwebp -q 70 {} -o {}.webp \;
</code></pre><p>Or bulk optimize your image sources with MozJPEG using <a href="https://github.com/danielgtaylor/jpeg-archive">jpeg-recompress</a>:</p>
<pre><code>find ./ -type f -name &#39;*.jpg&#39; -exec jpeg-recompress {} {} \;
</code></pre><p>and trim those SVGs down using <a href="https://github.com/svg/svgo">svgo</a> (which we’ll cover later on):</p>
<pre><code>find ./ -type f -name &#39;*.svg&#39; -exec svgo {} \;
</code></pre><p>Jeremy Wagner has a more comprehensive post on <a href="https://jeremywagner.me/blog/bulk-image-optimization-in-bash">image optimization using Bash</a> and another on doing this work in <a href="https://jeremywagner.me/blog/faster-bulk-image-optimization-in-bash">parallel</a> worth reading.</p>
<p><strong>Other WebP image processing and editing apps include:</strong></p>
<ul>
<li>Leptonica — An entire website of open source image processing and analysis
Apps.</li>
</ul>
<ul>
<li>Sketch supports outputting directly to WebP<ul>
<li>GIMP — Free, open source Photoshop alternative. Image editor.</li>
<li>ImageMagick — Create, compose, convert, or edit bitmap images. Free. Command-Line app.</li>
<li>Pixelmator — Commercial image editor for Mac.</li>
<li>Photoshop WebP Plugin — Free. Image import and export. From Google.</li>
</ul>
</li>
</ul>
<p><strong>Android:</strong> You can convert existing BMP, JPG, PNG or static GIF images to WebP format using Android Studio. For more information, see <a href="https://developer.android.com/studio/write/convert-webp.html">Create WebP Images Using Android Studio</a>.</p>
<h3 id="-a-id-how-do-i-view-webp-on-my-os-href-how-do-i-view-webp-on-my-os-how-do-i-view-webp-images-on-my-os-a-"><a id="how-do-i-view-webp-on-my-os" href="#how-do-i-view-webp-on-my-os">How do I view WebP images on my OS?</a></h3>
<p>While you can drag and drop WebP images to Blink-based browsers (Chrome, Opera, Brave) to preview them, you can also preview them directly from your OS using an add-on for either Mac or Windows.</p>
<p><a href="https://www.cnet.com/news/facebook-tries-googles-webp-image-format-users-squawk/">Facebook experimented with WebP</a> a few years ago and found that users who tried to right-click on photos and save them to disk noticed they wouldn’t be displayed outside their browser due to them being in WebP. There were three key problems here:</p>
<ul>
<li>&quot;Save as&quot; but unable to view WebP files locally. This was fixed by Chrome registering itself as a &quot;.webp&quot; handler.</li>
<li>&quot;Save as&quot; then attaching the image to an email and sharing with someone without Chrome. Facebook solved this by introducing a prominent &quot;download&quot; button in their UI and returning a JPEG when users requested the download.</li>
<li>Right click &gt; copy URL -&gt; share URL on the web. This was solved by <a href="https://www.igvita.com/2012/12/18/deploying-new-image-formats-on-the-web/">content-type negotiation</a>.</li>
</ul>

<p>These issues might matter less to your users, but is an interesting note on social shareability in passing. Thankfully today, utilities exist for viewing and working with WebP on different operating systems.</p>
<p>On Mac, try the <a href="https://github.com/Nyx0uf/qlImageSize">Quick Look plugin for WebP</a> (qlImageSize). It works pretty well:</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image22.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image22.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image22.jpg" />

<img
        class="small lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image22.jpg"
        alt="Desktop on a mac showing a WebP file previewed using the Quick Look plugin for WebP files"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image22.jpg"/>
</noscript>
</picture>
</figure>


<p>On Windows, you can also download the <a href="https://storage.googleapis.com/downloads.webmproject.org/releases/webp/WebpCodecSetup.exe">WebP codec package</a> allowing WebP images to be previewed in the File Explorer and Windows Photo Viewer.  </p>
<h3 id="-a-id-how-do-i-serve-webp-href-how-do-i-serve-webp-how-do-i-serve-webp-a-"><a id="how-do-i-serve-webp" href="#how-do-i-serve-webp">How do I serve WebP?</a></h3>
<p>Browsers without WebP support can end up not displaying an image at all, which isn’t ideal. To avoid this there are a few strategies we can use for conditionally serving WebP based on browser support.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/play-format-webp.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/play-format-webp.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/play-format-webp.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/play-format-webp.jpg"
        alt="The Chrome DevTools Network panel displaying the waterfall for the Play Store in Chrome, where WebP is served."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/play-format-webp.jpg"/>
</noscript>
</picture>
<figcaption>The Chrome DevTools Network panel highlighting WebP files being conditionally served to Blink-based browsers under the ‘Type’ column.</figcaption>
</figure>

<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/play-format-type.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/play-format-type.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/play-format-type.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/play-format-type.jpg"
        alt="While the Play store delivers WebP to Blink, it falls back to JPEGs for browsers like Firefox."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/play-format-type.jpg"/>
</noscript>
</picture>
<figcaption>While the Play store delivers WebP to Blink, it falls back to JPEGs for browsers like Firefox.</figcaption>
</figure>


<p>Here are some of the options for getting WebP images from your server to your user:</p>
<p><strong>Using .htaccess to Serve WebP Copies</strong></p>
<p>Here’s how to use a .htaccess file to serve WebP files to supported browsers when a matching .webp version of a JPEG/PNG file exists on the server.</p>
<p>Vincent Orback recommended this approach:</p>
<p>Browsers can <a href="http://vincentorback.se/blog/using-webp-images-with-htaccess/">signal WebP support explicitly</a> via an <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept">Accept header</a>. If you control your backend, you can return a WebP version of an image if it exists on disk rather than formats like JPEG or PNG. This isn’t always possible however (e.g. for static hosts like GitHub pages or S3) so be sure to check before considering this option.</p>
<p>Here is a sample .htaccess file for the Apache web server:</p>
<pre><code>&lt;IfModule mod_rewrite.c&gt;

  RewriteEngine On

  # Check if browser support WebP images
  RewriteCond %{HTTP_ACCEPT} image/webp

  # Check if WebP replacement image exists
  RewriteCond %{DOCUMENT_ROOT}/$1.webp -f

  # Serve WebP image instead
  RewriteRule (.+)\.(jpe?g|png)$ $1.webp [T=image/webp,E=accept:1]

&lt;/IfModule&gt;

&lt;IfModule mod_headers.c&gt;

    Header append Vary Accept env=REDIRECT_accept

&lt;/IfModule&gt;

AddType  image/webp .webp
</code></pre><p>If there are issues with the .webp images appearing on the page, make sure that the image/webp MIME type is enabled on your server.</p>
<p>Apache: add the following code to your .htaccess file:</p>
<pre><code>AddType image/webp .webp
</code></pre><p>Nginx: add the following code to your mime.types file:</p>
<pre><code>image/webp webp;
</code></pre><aside class="note"><b>Note:</b> Vincent Orback has a sample <a href="https://github.com/vincentorback/WebP-images-with-htaccess">htaccess config</a> for serving WebP for reference and Ilya Grigorik maintains a collection of <a href="https://github.com/igrigorik/webp-detect">configuration
scripts for serving WebP</a> that can be useful.</aside>


<p><strong>Using the <code>&lt;picture&gt;</code> Tag</strong></p>
<p>The browser itself is capable of choosing which image format to display through the use of the <code>&lt;picture&gt;</code> tag. The <code>&lt;picture&gt;</code> tag utilizes multiple <code>&lt;source&gt;</code> elements, with one <code>&lt;img&gt;</code> tag, which is the actual DOM element which contains the image. The browser cycles through the sources and retrieves the first match. If the <code>&lt;picture&gt;</code> tag isn’t supported in the user’s browser, a <code>&lt;div&gt;</code> is rendered and the <code>&lt;img&gt;</code> tag is used.</p>
<aside class="note"><b>Note:</b> Be careful with the position of <code>&lt;source&gt;</code> as order matters. Don’t place image/webp sources after legacy formats, but instead put them before. Browsers that understand it will use them and those that don’t will move onto more widely supported frameworks. You can also place your images in order of file size if they’re all the same physical size (when not using the <code>media</code> attribute). Generally this is the same order as putting legacy last. </aside>

<p>Here is some sample HTML:</p>
<pre><code class="lang-html">&lt;picture&gt;
  &lt;source srcset=&quot;/path/to/image.webp&quot; type=&quot;image/webp&quot;&gt;
  &lt;img src=&quot;/path/to/image.jpg&quot; alt=&quot;&quot;&gt;
&lt;/picture&gt;

&lt;picture&gt;   
    &lt;source srcset=&#39;paul_irish.jxr&#39; type=&#39;image/vnd.ms-photo&#39;&gt;  
    &lt;source srcset=&#39;paul_irish.jp2&#39; type=&#39;image/jp2&#39;&gt;
    &lt;source srcset=&#39;paul_irish.webp&#39; type=&#39;image/webp&#39;&gt;
    &lt;img src=&#39;paul_irish.jpg&#39; alt=&#39;paul&#39;&gt;
&lt;/picture&gt;

&lt;picture&gt;
   &lt;source srcset=&quot;photo.jxr&quot; type=&quot;image/vnd.ms-photo&quot;&gt;
   &lt;source srcset=&quot;photo.jp2&quot; type=&quot;image/jp2&quot;&gt;
   &lt;source srcset=&quot;photo.webp&quot; type=&quot;image/webp&quot;&gt;
   &lt;img src=&quot;photo.jpg&quot; alt=&quot;My beautiful face&quot;&gt;
&lt;/picture&gt;
</code></pre>
<p><strong>Automatic CDN conversion to WebP</strong></p>
<p>Some CDNs support automated conversion to WebP and can use client hints to serve up WebP images <a href="http://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints">whenever possible</a>. Check with your CDN to see if WebP support is included in their service. You may have an easy solution just waiting for you.</p>
<p><strong>WordPress WebP support</strong></p>
<p><strong>Jetpack</strong> — Jetpack, a popular WordPress plugin, includes a CDN image service called <a href="https://jetpack.com/support/photon/">Photon</a>. With Photon you get seamless WebP image support. The Photon CDN is included in Jetpack&#39;s free level, so this is a good value and a hands-off implementation. The drawback is that Photon resizes your image, puts a query string in your URL and there is an extra DNS lookup required for each image.</p>
<p><strong>Cache Enabler and Optimizer</strong> — If you are using WordPress, there is at least one halfway-open source option. The open source plugin <a href="https://wordpress.org/plugins/cache-enabler/">Cache Enabler</a> has a menu checkbox option for caching WebP images to be served if available and the current user’s browser supports them. This makes serving WebP images easy. There is a drawback: Cache Enabler requires the use of a sister program called Optimizer, which has an annual fee. This seems out of character for a genuinely open source solution.  </p>
<p><strong>Short Pixel</strong> — Another option for use with Cache Enabler, also at a cost, is Short Pixel. Short Pixel functions much like Optimizer, described above. You can optimize up to 100 images a month for free.</p>
<p><strong>Compressing Animated GIFs and why <code>&lt;video&gt;</code> is better</strong></p>
<p>Animated GIFs continue to enjoy widespread use, despite being a very limited format. Although everything from social networks to popular media sites embed animated GIFs heavily, the format was <em>never</em> designed for video storage or animation. In fact, the <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF89a spec</a> notes ‘the GIF is not intended as a platform for animation’. The <a href="http://gifbrewery.tumblr.com/post/39564982268/can-you-recommend-a-good-length-of-clip-to-keep-gifs">number of colors, number of frames and dimensions</a> all impact animated GIF size. Switching to video offers the largest savings.  </p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/animated-gif.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/animated-gif.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/animated-gif.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/animated-gif.jpg"
        alt="Animated GIF vs. Video: a comparison of file sizes at ~equivalent quality for different formats."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/q_100/v1502426282/essential-image-optimization/animated-gif.jpg"/>
</noscript>
</picture>
<figcaption>Animated GIF vs. Video: a comparison of file sizes at ~equivalent quality for different formats.</figcaption>
</figure>

<p><strong>Delivering the same file as an MP4 video can often shave 80% or more off your file-size.</strong> Not only do GIFs often waste significant bandwidth, but they take longer to load, include fewer colors and generally offer sub-part user experiences. You may have noticed animated GIFs uploaded to Twitter perform better on Twitter than on other websites. <a href="http://mashable.com/2014/06/20/twitter-gifs-mp4/#fiiFE85eQZqW">Animated GIFs on Twitter aren’t actually GIFs</a>. To improve user experience and reduce bandwidth consumption, animated GIFs uploaded to Twitter are actually converted to video. Similarly, <a href="https://thenextweb.com/insider/2014/10/09/imgur-begins-converting-gif-uploads-mp4-videos-new-gifv-format/">Imgur converts GIFs to videos</a> on upload, silently converting it to an MP4 for you.</p>
<p>Why are GIFs many times larger? Animated GIFs store each frame as a lossless GIF image – yes, lossless. The degraded quality we often experience is due to GIFs being limited to a 256-color palette. The format is often large as it doesn’t consider neighbor frames for compression, unlike video codecs like H.264. An MP4 video stores each key frame as a lossy JPEG, which discards some of the original data to achieve better compression.</p>
<p><strong>If you can switch to videos</strong></p>
<ul>
<li>Use <a href="https://www.ffmpeg.org/">ffmpeg</a> to convert your animated GIFs (or sources) to H.264 MP4s. I use this one-liner from<a href="http://rigor.com/blog/2015/12/optimizing-animated-gifs-with-html5-video"> Rigor</a>:
ffmpeg -i animated.gif -movflags faststart -pix_fmt yuv420p -vf &quot;scale=trunc(iw/2)<em>2:trunc(ih/2)</em>2&quot; video.mp4</li>
<li>ImageOptim API also supports <a href="https://imageoptim.com/api/ungif">converting animated gifs to WebM/H.264 video</a>, <a href="https://github.com/pornel/undither#examples">removing dithering from GIFs</a> which can help video codecs compress even more.</li>
</ul>
<p><strong>If you must use animated GIFs</strong></p>
<ul>
<li>Tools like Gifsicle can strip metadata, unused palette entries and minimize what changes between frames</li>
<li>Consider a lossy GIF encoder. The <a href="https://github.com/pornel/giflossy">Giflossy</a> fork of Gifsicle supports this with the <code>—lossy</code> flag and can shave ~60-65% off size. There’s also a nice tool based on it called <a href="https://github.com/vvo/gifify">Gifify</a>. For non-animated GIFs, convert them to PNG or WebP.</li>
</ul>
<p>For more information, checkout the<a href="https://rigor.com/wp-content/uploads/2017/03/TheBookofGIFPDF.pdf"> Book of GIF</a> by Rigor.</p>
<h2 id="-a-id-svg-optimization-href-svg-optimization-svg-optimization-a-"><a id="svg-optimization" href="#svg-optimization">SVG Optimization</a></h2>
<p>Keeping SVGs lean means stripping out anything unnecessary. SVG files created with editors usually contain a large quantity of redundant information (metadata, comments, hidden layers and so forth). This content can often be safely removed or converted to a more minimal form without impacting the final SVG that’s being rendered.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image26.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image26.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image26.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image26.jpg"
        alt="svgo"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image26.jpg"/>
</noscript>
</picture>
<figcaption><a href="https://jakearchibald.github.io/svgomg/">SVGOMG</a>, by Jake Archibald, is a GUI interface enabling you to optimize your SVGs to your preference  by selecting optimizations, with a live preview of the outputted markup </figcaption>
</figure>

<p><strong>Some general rules for SVG optimization (SVGO):</strong></p>
<ul>
<li>Minify and gzip your SVG files. SVGs are really just text assets expressed in XML, like CSS, HTML and JavaScript, and should be minified and gzipped to improve performance.</li>
<li>Instead of paths, use predefined SVG shapes like <code>&lt;rect&gt;</code>, <code>&lt;circle&gt;</code>, <code>&lt;ellipse&gt;</code>, <code>&lt;line&gt;</code> and <code>&lt;polygon&gt;</code>. Preferring predefined shapes decreases how much markup is needed to produce a final image, meaning less code to parse and rasterize by the browser. Reducing SVG complexity means a browser can display it more quickly.</li>
<li>If you must use paths, try to reduce your curves and paths. Simplify and combine them where you can. Illustrator’s <a href="http://jlwagner.net/talks/these-images/#/2/10">simplify tool</a> is adept at removing superfluous points in even complex artwork while smoothing out irregularities.</li>
<li>Avoid using groups. If you can’t, try to simplify them.</li>
<li>Delete layers that are invisible.</li>
<li>Avoid any Photoshop or Illustrator effects. They can get converted to large raster images.</li>
<li>Double check for any embedded raster images that aren’t SVG-friendly</li>
<li>Use a tool to optimize your SVGs. <a href="https://jakearchibald.github.io/svgomg/">SVGOMG</a> is a super handy web-based GUI for <a href="https://github.com/svg/svgo">SVGO</a> by Jake Archibald that I’ve found invaluable. If you use Sketch, the <a href="[Sketch plugin for running SVGO](https://www.sketchapp.com/extensions/plugins/svgo-compressor/">SVGO Compressor plugin</a>) can be used when exporting to shrink the file size.</li>
</ul>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/svgo-precision.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/svgo-precision.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/svgo-precision.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/svgo-precision.jpg"
        alt="svgo precision reduction can sometimes have a positive impact on size"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/svgo-precision.jpg"/>
</noscript>
</picture>
<figcaption>An example of running an SVG source through SVGO in high-precision mode (leading to a 29% improvement in size) vs. low-precision mode (a 38% size improvement).</figcaption>
</figure>


<p><a href="https://github.com/svg/svgo">SVGO</a> is a Node-based tool for optimizing SVG. SVGO can reduce file-size by lowering the <em>precision</em> of numbers in your <path> definitions. Each digit after a point adds a byte and this is why changing the precision (number of digits) can heavily influence file size. Be very very careful with changing precision however as it can visually impact how your shapes look.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image28.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image28.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image28.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image28.jpg"
        alt="where svgo can go wrong, oversimplifying paths and artwork"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image28.jpg"/>
</noscript>
</picture>
<figcaption>It’s important to note that while SVGO does well in the previous example without over-simplifying paths and shapes, there are plenty of cases where this may not be the case. Observe how the light strip on the above rocket is distorted at a lower precision.</figcaption>
</figure>

<p><strong>Using SVGO at the command-line:</strong></p>
<p>SVGO can be installed as a <a href="https://www.npmjs.com/package/svgo">global npm CLI</a> should you prefer that to a GUI:</p>
<pre><code>npm i -g svgo
</code></pre><p>This can then be run against a local SVG file as follows:</p>
<pre><code>svgo input.svg -o output.svg
</code></pre><p>It supports all the options you might expect, including adjusting floating point precision:</p>
<pre><code>svgo input.svg --precision=1 -o output.svg
</code></pre><p>See the SVGO <a href="https://github.com/svg/svgo">readme</a> for the full list of supported options.</p>
<p><strong>Don’t forget to compress SVGs!</strong></p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/before-after-svgo.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/before-after-svgo.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/before-after-svgo.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/before-after-svgo.jpg"
        alt="before and after running an image through svgo"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/before-after-svgo.jpg"/>
</noscript>
</picture>
</figure>

<p>Also, don’t forget to <a href="https://calendar.perfplanet.com/2014/tips-for-optimising-svg-delivery-for-the-web/">Gzip your SVG assets</a> or serve them using Brotli. As they’re text based, they’ll compress really well (~50% of the original sources).</p>
<p>When Google shipped a new logo, we announced that the <a href="https://twitter.com/addyosmani/status/638753485555671040">smallest</a> version of it was only 305 bytes in size.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image30.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image30.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image30.jpg" />

<img
        class="lazyload very-small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image30.jpg"
        alt="the smallest version of the new google logo was only 305 bytes in size"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image30.jpg"/>
</noscript>
</picture>
</figure>

<p>There are <a href="https://www.clicktorelease.com/blog/svg-google-logo-in-305-bytes/">lots of advanced SVG tricks</a> you can use to trim this down even further (all the way to 146 bytes)! Suffice to say, whether it’s through tools or manual clean-up, there’s probably a <em>little</em> more you can shave off your SVGs.</p>
<p><strong>SVG Sprites</strong></p>
<p>SVG can be <a href="https://css-tricks.com/icon-fonts-vs-svg/">powerful</a> for icons, offering a way to represent visualizations as a sprite without the <a href="https://www.filamentgroup.com/lab/bulletproof_icon_fonts.html">quirky</a> workarounds needed for icon fonts. It has more granular CSS styling control than icon fonts (SVG stroke properties),  better positioning control (no need to hack around pseudo-elements and CSS <code>display</code>) and SVGs are much more <a href="http://www.sitepoint.com/tips-accessible-svg/">accessible</a>.</p>
<p>Tools like <a href="https://github.com/jkphl/svg-sprite">svg-sprite</a> and <a href="https://icomoon.io/">IcoMoon</a> can automate combining SVGs into sprites which can be used via a <a href="https://css-tricks.com/css-sprites/">CSS Sprite</a>, <a href="https://css-tricks.com/svg-use-with-external-reference-take-2">Symbol Sprite</a> or <a href="http://simurai.com/blog/2012/04/02/svg-stacks">Stacked Sprite</a>. Una Kravetz has a practical <a href="https://una.im/svg-icons/#💁">write-up</a> on how to use gulp-svg-sprite for an SVG sprite workflow worth checking out. Sara Soudein also covers <a href="https://www.sarasoueidan.com/blog/icon-fonts-to-svg/">making the transition from icon fonts to SVG</a> on her blog.</p>
<p><strong>Further reading</strong></p>
<p>Sara Soueidan’s <a href="https://calendar.perfplanet.com/2014/tips-for-optimising-svg-delivery-for-the-web/">tips for optimising SVG delivery for the web</a> and Chris Coyier’s <a href="https://abookapart.com/products/practical-svg">Practical SVG book</a> are excellent. I’ve also found Andreas Larsen’s optimizing SVG posts enlightening (<a href="https://medium.com/larsenwork-andreas-larsen/optimising-svgs-for-web-use-part-1-67e8f2d4035">part 1</a>,<a href="https://medium.com/larsenwork-andreas-larsen/optimising-svgs-for-web-use-part-2-6711cc15df46">part 2</a>).<a href="https://medium.com/sketch-app-sources/preparing-and-exporting-svg-icons-in-sketch-1a3d65b239bb">Preparing and exporting SVG icons in Sketch</a> was also a great read.</p>
<h2 id="-a-id-avoid-recompressing-images-lossy-codecs-href-avoid-recompressing-images-lossy-codecs-avoid-recompressing-images-with-lossy-codecs-a-"><a id="avoid-recompressing-images-lossy-codecs" href="#avoid-recompressing-images-lossy-codecs">Avoid recompressing images with lossy codecs</a></h2>
<p>It is recommended to always compress from the original image. Recompressing images has consequences. Let’s say you take a JPEG that’s already been compressed with a quality of 60. If you recompress this image with lossy encoding, it will look worse. Each additional round of compression is going to introduce generational loss – information will be lost and compression artifacts will start to build up. Even if you’re re-compressing at a high quality setting.</p>
<p>To avoid this trap, <strong>set the lowest good quality you’re willing to accept in the first place</strong> and you’ll get maximum file savings from the start. You then avoid this trap because any file-size reductions from quality reduction alone will look bad.</p>
<p>Re-encoding a lossy file will almost always give you a smaller file, but this doesn’t mean you’re getting as much quality out of it as you may think.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/generational-loss.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/generational-loss.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/generational-loss.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/generational-loss.jpg"
        alt="generational loss when re-encoding an image multiple times"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/generational-loss.jpg"/>
</noscript>
</picture>
<figcaption>Above, from this <a href="https://www.youtube.com/watch?v=w7vXJbLhTyI">excellent video</a> and <a href="http://cloudinary.com/blog/why_jpeg_is_like_a_photocopier">accompanying article</a> by Jon Sneyers, we can see the generational loss impact of recompression using several formats. This is a problem you may have run into if saving (already compressed) images from social networks and re-uploading them (causing recompression). Quality loss will build up.</figcaption>
</figure>


<p>MozJPEG (perhaps accidentally) has a better resistance to recompression degradation thanks to trellis quantization. Instead of compressing all DCT values as they are exactly, it can check close values within a +1/-1 range to see if similar values compress to fewer bits. Lossy FLIF has a hack similar to lossy PNG in that prior to (re)compression, it can look at the data and decide what to throw away. Recompressed PNGs have ‘holes’ it can detect to avoid changing data further.</p>
<p><strong>When editing your source files, store them in a lossless format like PNG or TIFF, so you preserve as much quality as you can.</strong> Your build tools or image compression service than then handle outputting the compressed version you serve to users with minimal loss in quality.</p>
<h2 id="-a-id-reduce-unnecessary-image-decode-costs-href-reduce-unnecessary-image-decode-costs-reduce-unnecessary-image-decode-and-resize-costs-a-"><a id="reduce-unnecessary-image-decode-costs" href="#reduce-unnecessary-image-decode-costs">Reduce unnecessary image decode and resize costs</a></h2>
<p>We’ve all shipped large, higher resolution images than needed to our users before. This has a cost to it. Decoding and resizing images are expensive operations for a browser on average mobile hardware. If sending down large images and rescaling using CSS or width/height attributes, you’re likely to see this happen and it can impact performance.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503503389/essential-image-optimization/image-pipeline.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503503389/essential-image-optimization/image-pipeline.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503503389/essential-image-optimization/image-pipeline.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503503389/essential-image-optimization/image-pipeline.jpg"
        alt="There are many steps involved in a browser grabbing an image specified in a tag and displaying it on a screen. These include request, decode, resize, copy to GPU and display."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503503389/essential-image-optimization/image-pipeline.jpg"/>
</noscript>
</picture>
<figcaption>
When a browser fetches an image, it has to decode the image from the original source format (e.g. JPEG) to a bitmap in memory. Often the image needs to be resized (e.g. width has been set to a percentage of its container). Decoding and resizing images are expensive and can delay how long it takes for an image to be displayed. </figcaption>
</figure>

<p>Sending down images that a browser can render without needing to resize at all is ideal. So, serve the smallest images for your target screen sizes and resolutions, taking advantage of <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images"><code>srcset</code> and <code>sizes</code></a> – we’ll cover <code>srcset</code> shortly.</p>
<p>Omitting the <code>width</code> or <code>height</code> attributes on an image can also negatively impact performance. Without them, a browser assigns a smaller placeholder region for the image until sufficient bytes have arrived for it to know the correct dimensions. At that point, the document layout must be updated in what can be a costly step called reflow.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/devtools-decode.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/devtools-decode.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/devtools-decode.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/devtools-decode.jpg"
        alt="image decode costs shown in the chrome devtools"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/devtools-decode.jpg"/>
</noscript>
</picture>
<figcaption>Browsers have to go through a number of steps to paint images on the screen. In addition to fetching them, images need to be decoded and often resized. These events can be
audited in the Chrome DevTools <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference">Timeline</a>. </figcaption>
</figure>

<p>Larger images also come with an increase in memory size costs. Decoded images are ~4 bytes per pixel. If
you’re not careful, you can literally crash the browser; on low-end devices it doesn’t take that much to
start memory swapping. So, keep an eye on your image decode, resize and memory costs.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503695136/essential-image-optimization/image-decoding-mobile.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503695136/essential-image-optimization/image-decoding-mobile.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503695136/essential-image-optimization/image-decoding-mobile.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503695136/essential-image-optimization/image-decoding-mobile.jpg"
        alt="Decoding images can be incredibly costly on average and lower-end mobile hardware"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503695136/essential-image-optimization/image-decoding-mobile.jpg"/>
</noscript>
</picture>
<figcaption>Decoding images can be incredibly costly on average and lower-end mobile phones. In some cases it can be 5× slower to decode (if not longer).</figcaption>
</figure>

<p>When building their new <a href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3">mobile web experience</a>, Twitter improved image decode performance by ensuring they served appropriately sized images to their users. This took decode time for many images in the Twitter timeline from ~400ms all the way down to ~19!</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/image-decoding.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/image-decoding.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/image-decoding.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/image-decoding.jpg"
        alt="Chrome DevTools Timeline/Performance panel highlighting image decode times before and after Twitter Lite optimized their image pipeline. Before was higher."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/image-decoding.jpg"/>
</noscript>
</picture>
<figcaption>Chrome DevTools Timeline/Performance panel highlighting image decode times (in green) before and after Twitter Lite optimized their image pipeline.</figcaption>
</figure>

<h3 id="-a-id-delivering-hidpi-with-srcset-href-delivering-hidpi-with-srcset-delivering-hidpi-images-using-srcset-a-"><a id="delivering-hidpi-with-srcset" href="#delivering-hidpi-with-srcset">Delivering HiDPI images using <code>srcset</code></a></h3>
<p>Users may access your site through a range of mobile and desktop devices with high-resolution screens. The <a href="https://stackoverflow.com/a/21413366">Device Pixel Ratio</a> (DPR) (also called the ‘CSS pixel ratio’) determines how a device’s screen resolution is interpreted by CSS. DPR was created by phone manufacturers to enable increasing the resolution and sharpness of mobile screens without making elements appear too small.</p>
<p>To match the image quality users might expect, deliver the most appropriate resolution images to their devices. Sharp, high-DPR images (e.g. 2×, 3×) can be served to devices that support them. Low and standard-DPR images should be served to users without high-res screens as such 2×+ images will
often weigh significantly more bytes.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502570356/essential-image-optimization/device-pixel-ratio.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502570356/essential-image-optimization/device-pixel-ratio.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502570356/essential-image-optimization/device-pixel-ratio.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502570356/essential-image-optimization/device-pixel-ratio.jpg"
        alt="A diagram of the device pixel ratio at 1×, 2× and 3×. Image quality appears to sharpen
        as DPR increases and a visual is shown comparing device pixels to CSS pixels."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502570356/essential-image-optimization/device-pixel-ratio.jpg"/>
</noscript>
</picture>
<figcaption>Device Pixel Ratio: Many sites track the DPR for popular devices including <a href="https://material.io/devices/">material.io</a> and <a href="https://mydevice.io/devices/">mydevice.io</a>.</figcaption>
</figure>


<p><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">srcset</a> allows a browser to select the best available image per device, e.g. selecting a 2× image for a 2× mobile display. Browsers without <code>srcset</code> support can fallback to the default <code>src</code> specified in the <code>&lt;img&gt;</code> tag.</p>
<pre><code>&lt;img srcset=&quot;paul-irish-320w.jpg,
             paul-irish-640w.jpg 2x,
             paul-irish-960w.jpg 3x&quot;
     src=&quot;paul-irish-960w.jpg&quot; alt=&quot;Paul Irish cameo&quot;&gt;
</code></pre><p>Image CDNs like <a href="http://cloudinary.com/blog/how_to_automatically_adapt_website_images_to_retina_and_hidpi_devices">Cloudinary</a> and <a href="https://docs.imgix.com/apis/url/dpr">Imgix</a> both support controlling image density to serve the best
density to users from a single canonical source.</p>
<aside class="note"><b>Note:</b> You can learn more about Device Pixel Ratio and responsive images in this free <a href="https://www.udacity.com/course/responsive-images--ud882">Udacity</a> course and the <a href="https://developers.google.com/web/fundamentals/design-and-ui/responsive/images">Images</a> guide on Web Fundamentals.</aside>

<p>A friendly reminder that <a href="https://www.smashingmagazine.com/2016/01/leaner-responsive-images-client-hints/">Client Hints</a> can also provide an alternative to specifying each possible pixel density and format in your responsive image markup. Instead, they append this information to the HTTP request so web servers can pick the best fit for the current device’s screen density.</p>
<h3 id="-a-id-art-direction-href-art-direction-art-direction-a-"><a id="art-direction" href="#art-direction">Art direction</a></h3>
<p>Although shipping the right resolution to users is important, some sites also need to think about this in terms of <strong><a href="http://usecases.responsiveimages.org/#art-direction">art direction</a></strong>. If a user is on a smaller screen, you may want to crop or zoom in and display the subject to make best use of available space. Although art direction is outside the scope of this write-up, services like<a href="http://cloudinary.com/blog/automatically_art_directed_responsive_images%20"> Cloudinary</a> provide APIs to try automating this as much as possible.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/responsive-art-direction.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/responsive-art-direction.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/responsive-art-direction.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/responsive-art-direction.jpg"
        alt="responsive art direction in action, adapting to show more or less of an image in a cropped manner depending on device"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/responsive-art-direction.jpg"/>
</noscript>
</picture>
<figcaption>Art direction: Eric Portis put together an excellent <a href="https://ericportis.com/etc/cloudinary/">sample</a> of how responsive images can be used for art-direction. This example adapts the main hero image’s visual characteristics at different breakpoints to make best use of the available space.</figcaption>
</figure>

<h2 id="-a-id-color-management-href-color-management-color-management-a-"><a id="color-management" href="#color-management">Color management</a></h2>
<p>There are at least three different perspectives of color: biology, physics and print. In biology, color is a <a href="http://hubel.med.harvard.edu/book/ch8.pdf">perceptual phenomenon</a>. Objects reflect light in different combinations of wavelengths. Light receptors in our eyes translate these wavelengths into the sensation we know as color. In physics, it’s light that matters – light frequencies and brightness. Print is more about color wheels, inks and artistic models.</p>
<p>Ideally, every screen and web browser in the world would display color exactly the same. Unfortunately, due to a number of inherent inconsistencies, they don’t. Color management allows us to reach a compromise on displaying color through color models, spaces and profiles.</p>
<h4 id="color-models">Color models</h4>
<p><a href="https://en.wikipedia.org/wiki/Gamma_correction">Color models</a> are a system for generating a complete range of colors from a smaller set of primary colors. There are different types of color spaces which use different parameters to control colors. Some color spaces have fewer control parameters than others – e.g. grayscale only has a single parameter for controlling brightness between black and white colors.</p>
<p>Two common color models are additive and subtractive. Additive color models (like RGB, used for digital displays) use light to show color while subtractive color models (like CMYK, used in printing) work by taking light away.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504564914/colors_ept6f2.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1504564914/colors_ept6f2.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504564914/colors_ept6f2.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504564914/colors_ept6f2.jpg"
        alt="sRGB, Adobe RGB and ProPhoto RGB" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504564914/colors_ept6f2.jpg"/>
</noscript>
</picture>
<figcaption>In RGB red, green and blue light are added in different combinations to produce a broad spectrum of colors. CYMK (cyan, magenta, yellow and black) works through different colors of ink subtracting brightness from white paper.  </figcaption>
</figure>

<p><a href="https://www.designersinsights.com/designer-resources/understanding-color-models/">Understanding Color Models and Spot Color Systems</a> has a good description of other color models and modes, such as HSL, HSV and LAB.</p>
<h4 id="color-spaces">Color spaces</h4>
<p><a href="http://www.dpbestflow.org/color/color-space-and-color-profiles#space">Color spaces</a> are a specific range of colors that can be represented for a given image. For example, if an image contains up to 16.7 million colors, different color spaces allow the use of narrower or wider ranges of these colors. Some developers refer to color models and color spaces as the same thing.</p>
<p><a href="https://en.wikipedia.org/wiki/SRGB">sRGB</a> was designed to be a <a href="https://www.w3.org/Graphics/Color/sRGB.html">standard</a> color space for the web and is based on RGB. It’s a small color space that is typically considered the lowest common denominator and is the safest option for color management cross-browser. Other color spaces (such as <a href="https://en.wikipedia.org/wiki/Adobe_RGB_color_space">Adobe RGB</a> or <a href="https://en.wikipedia.org/wiki/ProPhoto_RGB_color_space">ProPhoto RGB</a> – used in Photoshop and Lightroom) can represent more vibrant colors than sRGB but as the latter is more ubiquitous across most web browsers, games and monitors, it’s what is generally focused on.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504565044/color-wheel_hazsbk.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1504565044/color-wheel_hazsbk.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504565044/color-wheel_hazsbk.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504565044/color-wheel_hazsbk.jpg"
        alt="sRGB, Adobe RGB and ProPhoto RGB" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504565044/color-wheel_hazsbk.jpg"/>
</noscript>
</picture>
<figcaption>Above we can see a visualization of gamut – the range of colors a color space can define.</figcaption>
</figure>

<p>Color spaces have three channels (red, green and blue). There are 255 colors possible in each channel under 8-bit mode, bringing us to a total of 16.7 million colors. 16-bit images can show trillions of colors.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504564915/srgb-rgb_ntuhi4.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1504564915/srgb-rgb_ntuhi4.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504564915/srgb-rgb_ntuhi4.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504564915/srgb-rgb_ntuhi4.jpg"
        alt="sRGB, Adobe RGB and ProPhoto RGB" />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504564915/srgb-rgb_ntuhi4.jpg"/>
</noscript>
</picture>
<figcaption>A comparison of sRGB, Adobe RGB and ProPhoto RGB using an image from <a href="https://yardstick.pictures/tags/img%3Adci-p3">Yardstick</a>. It’s incredibly hard to show this concept in sRGB, when you can’t show colors that can’t be seen. A regular photo in sRGB vs wide gamut should have everything identical, except most saturated ‘juicy’ colors.</figcaption>
</figure>

<p>The differences in color spaces (like sRGB, Adobe RGB and ProPhoto RGB) are their gamut (the range of colors they can reproduce with shades), illuminant and <a href="http://blog.johnnovak.net/2016/09/21/what-every-coder-should-know-about-gamma/">gamma</a> curves. sRGB is ~20% smaller than Adobe RGB and ProPhoto RGB is ~<a href="http://www.petrvodnakphotography.com/Articles/ColorSpace.htm">50% larger</a> than Adobe RGB. The above image sources are from <a href="http://clippingpathzone.com/blog/essential-photoshop-color-settings-for-photographers">Clipping Path</a>.</p>
<p><a href="http://www.astramael.com/">Wide-gamut</a> is a term describing color spaces with a gamut larger than sRGB. These types of displays are becoming more common. That said, many digital displays are still simply unable to display color profiles that are significantly better than sRGB. When saving for the web in Photoshop, consider using the ‘Convert to sRGB’ option unless targeting users with higher-end wide-gamut screens.</p>
<aside class="key-point"><b>Note:</b> When working with original photography, avoid using sRGB as your primary color space. It’s smaller than the color spaces most cameras support and can cause clipping. Instead, work on a larger color space (like ProPhoto RGB) and output to sRGB when exporting for the web.</aside>

<p><strong>Are there any cases where wide gamut makes sense for web content?</strong></p>
<p>Yes. If an image contains very saturated/juicy/vibrant color and you care about it being just as juicy on screens that support it. However, in real photos that rarely happens. Often it’s easy to tweak color to make it appear vibrant, without it actually exceeding sRGB gamut</p>
<p>That’s because human color perception is not absolute, but relative to our surroundings and is easily fooled. If your image contains a fluorescent highlighter color, then you’ll have an easier time with wide gamut.</p>
<h4 id="gamma-correction-and-compression">Gamma correction and compression</h4>
<p><a href="https://en.wikipedia.org/wiki/Gamma_correction">Gamma correction</a> (or just Gamma) controls the overall brightness of an image. Changing the gamma can also alter the ratio of red to green and blue colors. Images without gamma correction can look like their colors are bleached out or too dark.</p>
<p>In video and computer graphics, gamma is used for compression, similar to data compression. This allows you to squeeze useful levels of brightness in fewer bits (8-bit rather than 12 or 16). Human perception of brightness is not linearly proportional to physical amount of light. Representing colors in their true physical form would be wasteful when encoding images for human eyes. Gamma compression is used to encode brightness on a scale that is closer to human perception.</p>
<p>With gamma compression useful scale of brightness fits in 8 bits of precision (0-255 used by most RGB colors). All of this comes from the fact that if colors used some unit with 1:1 relationship to physics, RGB values would be from 1 to million where values 0-1000 would look distinct, but values between 999000-1000000 would look identical. Imagine being in a dark room where there is just 1 candle. Light a second candle and you notice significant increases in brightness in the room light. Add a third candle and it’ll seem even brighter. Now imagine being in a room with 100 candles. Light the 101st candle, the 102nd. You won’t notice a change in brightness.</p>
<p>Even though in both cases, physically, exactly the same amount of light was added. So because eyes are less sensitive when light is bright, gamma compression ‘compresses’ bright values, so in physical terms bright levels are less precise but the scale is adjusted for humans so from the human perspective all values are equally precise.</p>
<aside class="key-point"><b>Note:</b> Gamma compression/correction here is different to the image gamma curves you might configure in Photoshop. When gamma compression works as it should, it doesn’t look like anything.</aside>

<h4 id="color-profiles">Color profiles</h4>
<p>A color profile is the information describing what that the color space of a device is. It’s used to convert between different color spaces. Profiles attempt to ensure an image looks as similar as possible on these different kinds of screens and mediums.</p>
<p>Images can have an embedded color profile as described by the <a href="http://www.color.org/icc_specs2.xalter">International Color Consortium</a> (ICC) to represent precisely how colors should appear. This is supported by different formats including JPEGs, PNGs, SVGs and <a href="https://developers.google.com/speed/webp/docs/riff_container">WebP</a> and most major browsers support embedded ICC profiles. When an image is displayed in an app and it knows the monitor’s capabilities, these colors can be adjusted based on the color profile.</p>
<aside class="key-point"><b>Note:</b> Some monitors have a color profile similar to sRGB and cannot display much better profiles so depending on your target users displays, there may be limited value in embedding them. Check who your target users are.</aside>

<p>Embedded color profiles can also heavily increase the size of your images (100KB+ occasionally) so be careful with embedding. Tools like ImageOptim will actually <a href="https://imageoptim.com/color-profiles.html">automatically</a> remove color profiles if it finds them. In contrast, with the ICC profile removed in the name of size reduction, browsers will be forced to display the image in your monitor’s color space which can lead to differences in expected saturation and contrast. Evaluate the trade-offs here make sense for your use case.</p>
<p><a href="https://ninedegreesbelow.com/photography/articles.html">Nine Degrees Below</a> have an excellent set of resources on ICC profile color management if you are interested in learning more about profiles.</p>
<h4 id="color-profiles-and-web-browsers">Color profiles and web browsers</h4>
<p>Earlier versions of Chrome did not have great support for color management, but this is improving in 2017 with <a href="https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/ptuKdRQwPAo">Color Correct Rendering</a>. Displays that are not sRGB (newer MacBook Pros) will convert colors from sRGB to the display profile. This will mean colors should look more similar across different systems and browsers. Safari, Edge and Firefox can now also take ICC profiles into account, so images with a different color profile (e.g. ICC) can now display them correctly whether your screen has wide gamut or not.</p>
<aside class="key-point"><b>Note:</b> For a great guide on how color applies to a broader spectrum of ways we work on the web, see the <a href="https://css-tricks.com/nerds-guide-color-web/">nerd’s guide to color on the web</a> by Sarah Drasner.</aside>

<h2 id="-a-id-image-sprites-href-image-sprites-image-spriting-a-"><a id="image-sprites" href="#image-sprites">Image spriting</a></h2>
<p><a href="https://developers.google.com/web/fundamentals/design-and-ui/responsive/images#use_image_sprites">Image sprites</a> (or CSS sprites) have a long history on the web, are supported by all browsers and have been a popular way to reduce the number of images a page loads by combining them into a single larger image that is sliced.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503693437/essential-image-optimization/i2_2ec824b0_1.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503693437/essential-image-optimization/i2_2ec824b0_1.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503693437/essential-image-optimization/i2_2ec824b0_1.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503693437/essential-image-optimization/i2_2ec824b0_1.jpg"
        alt="Image sprites are still widely used in large, production sites, including the Google homepage."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503693437/essential-image-optimization/i2_2ec824b0_1.jpg"/>
</noscript>
</picture>
<figcaption>Image sprites are still widely used in large, production sites, including the Google homepage.</figcaption>
</figure>

<p>Under HTTP/1.x, some developers used spriting to reduce HTTP requests. This came with a number of benefits, however care was needed as you quickly ran into challenges with cache-invalidation – changes to any small part of an image sprite would invalidate the entire image in a user’s cache.</p>
<p>Spriting may now however be an <a href="https://hpbn.co/http2/">HTTP/2</a> anti-pattern. With HTTP/2, it may be best to <a href="https://deliciousbrains.com/performance-best-practices-http2/">load individual images</a> since multiple requests within a single connection are now possible. Measure to evaluate whether this is the case for your own network setup.</p>
<h2 id="-a-id-lazy-load-non-critical-images-href-lazy-load-non-critical-images-lazy-load-non-critical-images-a-"><a id="lazy-load-non-critical-images" href="#lazy-load-non-critical-images">Lazy-load non-critical images</a></h2>
<p>Lazy loading is a web performance pattern that delays the loading of images in the browser until the user needs to see it. One example is, as you scroll, images load asynchronously on demand. This can further compliment the byte-savings you see from having an image compression strategy.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/scrolling-viewport.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/scrolling-viewport.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/scrolling-viewport.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/scrolling-viewport.jpg"
        alt="lazy-loading images"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/scrolling-viewport.jpg"/>
</noscript>
</picture>
</figure>

<p>Images that must appear ‘above the fold’, or when the web page first appears are loaded straight away. The images which follow ‘below the fold’, however, are not yet visible to the user. They do not have to be immediately loaded into the browser. They can be loaded later — or lazy loaded — only if and when the user scrolls down and it becomes necessary to show them.</p>
<p>Lazy loading is not yet natively supported in the browser itself (although there have been <a href="https://discourse.wicg.io/t/a-standard-way-to-lazy-load-images/1153/10">discussions</a> about it in the past). Instead, we use JavaScript to add this capability.</p>
<p><strong>Why is Lazy Loading Useful?</strong></p>
<p>This ‘lazy’ way of loading images only if and when necessary has many benefits:</p>
<ul>
<li><strong>Reduced data consumption</strong>: As you aren’t assuming the user will need every image fetched ahead of time, you’re only loading the minimal number of resources. This is always a good thing, especially on mobile with more restrictive data plans.</li>
<li><strong>Reduced battery consumption</strong>: Less workload for the user’s browser which can save on battery life.</li>
<li><strong>Improved download speed</strong>: Decreasing your overall page load time on an image heavy website from several seconds to almost nothing is a tremendous boost to user experience. In fact, it could be the difference between a user staying around to enjoy your site and just another bounce statistic.</li>
</ul>
<p><strong>But like all tools, with great power comes great responsibility.</strong></p>
<p><strong>Avoid lazy-loading images above the fold.</strong> Use it for long-lists of images (e.g. products) or lists of user avatars. Don’t use it for the main page hero image. Lazy-loading images above the fold can make loading visibly slower, both technically and for human perception. It can kill the browser’s preloader, progressive loading and the JavaScript can create extra work for the browser.</p>
<p><strong>Be very careful lazy-loading images when scrolling.</strong>  If you wait until the user is scrolling they are likely to see placeholders and may eventually get images, if they haven’t already scrolled past them. One recommendation would be to start lazy-loading after the above-the-fold images have loaded, loading all of the images independent of user interaction.</p>
<p><strong>Who Uses Lazy Loading?</strong></p>
<p>For examples of lazy loading, look at most any major site that hosts a lot of images. Some notable sites are <a href="https://medium.com/">Medium</a> and <a href="https://www.pinterest.com/">Pinterest</a>.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image35.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image35.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image35.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image35.jpg"
        alt="inline previews for images on medium.com"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image35.jpg"/>
</noscript>
</picture>
<figcaption>An example of Gaussian-blurred inline previews for images on Medium.com</figcaption>
</figure>

<p>A number of sites (such as Medium) display a small, Gaussian-blurred inline preview (a few 100 bytes) that transitions (lazy-loads) to a full-quality image once it has been fetched.</p>
<p>José M. Pérez has written about how to implement the Medium effect using <a href="https://jmperezperez.com/medium-image-progressive-loading-placeholder/">CSS filters</a> and experimented with <a href="https://jmperezperez.com/webp-placeholder-images/">different image formats</a> to support such placeholders. Facebook also did a write-up on their famous 200-byte approach for such placeholders for their <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">cover photos</a> that is worth a read. If you’re a Webpack user, <a href="https://lqip-loader.firebaseapp.com/">LQIP loader</a> can help automate some of this work away.</p>
<p>In fact, you can search for your favorite source of high-res photos and then scroll down the page. In almost all cases you’ll experience how the website loads only a few full-resolution images at a time, with the rest being placeholder colors or images. As you continue to scroll, the placeholder images are replaced with full-resolution images. This is lazy loading in action.</p>
<p>A technique that has been making the rounds recently is <em>vector-</em> rather than pixel-based low-quality image previews, piloted by Tobias Baldauf in his tool <a href="https://github.com/technopagan/sqip">SQIP</a>. This approach makes use of the utility <a href="https://github.com/fogleman/primitive">Primitive</a> to generate an SVG preview consisting of several simple shapes that approximate the main features visible inside the target image, optimizes the SVG using <a href="https://github.com/svg/svgo">SVGO</a>, and finally adds a Gaussian Blur filter to it; producing an SVG placeholder that weighs in at only ~800–1000 bytes, looks crisp on all screens, and provides a visual cue of the image contents to come. Both, lazy-loading and low-quality image previews, can obviously <a href="https://calendar.perfplanet.com/2017/progressive-image-loading-using-intersection-observer-and-sqip/">be combined</a>.</p>
<p><strong>How Can I Apply Lazy Loading to My Pages?</strong></p>
<p>There are a number of techniques and plugins available for lazy loading. I recommend <a href="https://github.com/aFarkas/lazysizes">lazysizes</a> by Alexander Farkas because of its decent performance, features, its optional integration with <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">Intersection Observer</a>, and support for plugins.</p>
<p><strong>What Can I Do with Lazysizes?</strong></p>
<p>Lazysizes is a JavaScript library. It requires no configuration. Download the minified js file and include it in your webpage.</p>
<p>Here is some example code taken from the README file:</p>
<p>Add the class ‘lazyload’ to your images/iframes in conjunction with a data-src and/or data-srcset attribute.</p>
<p>Optionally you can also add a src attribute with a low quality image:</p>
<pre><code class="lang-html">&lt;!-- non-responsive: --&gt;
&lt;img data-src=&quot;image.jpg&quot; class=&quot;lazyload&quot; /&gt;

&lt;!-- responsive example with automatic sizes calculation: --&gt;
&lt;img
    data-sizes=&quot;auto&quot;
    data-src=&quot;image2.jpg&quot;
    data-srcset=&quot;image1.jpg 300w,
    image2.jpg 600w,
    image3.jpg 900w&quot; class=&quot;lazyload&quot; /&gt;

&lt;!-- iframe example --&gt;

&lt;iframe frameborder=&quot;0&quot;
    class=&quot;lazyload&quot;
    allowfullscreen=&quot;&quot;
    data-src=&quot;//www.youtube.com/embed/ZfV-aYdU4uE&quot;&gt;
&lt;/iframe&gt;
</code></pre>
<p>For the web version of this book, I paired Lazysizes (although you can use any alternative)
with Cloudinary for on-demand responsive images. This allowed me the freedom to experiment
with different values for scale, quality, format and whether or not to progressively load
with minimal effort:</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502501095/essential-image-optimization/cloudinary-responsive-images.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502501095/essential-image-optimization/cloudinary-responsive-images.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502501095/essential-image-optimization/cloudinary-responsive-images.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502501095/essential-image-optimization/cloudinary-responsive-images.jpg"
        alt="Cloudinary supports on-demand control of image quality, format and several other features."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502501095/essential-image-optimization/cloudinary-responsive-images.jpg"/>
</noscript>
</picture>
</figure>

<p><strong>Lazysizes features include:</strong></p>
<ul>
<li>Automatically detects visibility changes on current and future lazyload elements</li>
<li>Includes standard responsive image support (picture and srcset)</li>
<li>Adds automatic sizes calculation and alias names for media queries feature</li>
<li>Can be used with hundreds of images/iframes on CSS and JS-heavy pages or web apps</li>
<li>Extendable: Supports plugins</li>
<li>Lightweight but mature solution</li>
<li>SEO improved: Does not hide images/assets from crawlers</li>
</ul>
<p><strong>More Lazy Loading Options</strong></p>
<p>Lazysizes is not your only option. Here are more lazy loading libraries:</p>
<ul>
<li><a href="http://ressio.github.io/lazy-load-xt/">Lazy Load XT</a></li>
<li><a href="https://github.com/dinbror/blazy">BLazy.js</a> (or [Be]Lazy)</li>
<li><a href="http://luis-almeida.github.io/unveil/">Unveil</a></li>
<li><a href="https://github.com/malchata/yall.js">yall.js (Yet Another Lazy Loader)</a> which is ~1KB and uses Intersection Observer where supported.</li>
</ul>
<p><strong>What’s the catch with Lazy Loading?</strong></p>
<ul>
<li>Screen readers, some search bots and any users with JavaScript disabled will not be able to view images lazy loaded with JavaScript. This is however something that we can work around with a <code>&lt;noscript&gt;</code> fallback.</li>
<li>Scroll listeners, such as used for determining when to load a lazy-loaded image, can have an adverse impact on browser scrolling performance. They can cause the browser to redraw many times, slowing the process to a crawl – however, smart lazy loading libraries will use throttling to mitigate this. One possible solution is Intersection Observer, which is supported by lazysizes.</li>
</ul>
<p>Lazy loading images is a widespread pattern for reducing bandwidth, decreasing costs, and improving user experience. Evaluate whether it makes sense for your experience. For further
reading see <a href="https://jmperezperez.com/lazy-loading-images/">lazy loading images</a> and <a href="https://jmperezperez.com/medium-image-progressive-loading-placeholder/">implementing Medium’s progressive loading</a>.</p>
<h2 id="-a-id-display-none-trap-href-display-none-trap-avoiding-the-display-none-trap-a-"><a id="display-none-trap" href="#display-none-trap">Avoiding the display:none trap</a></h2>
<p>Older responsive image solutions have mistaken how browsers handle image requests when setting the CSS  <code>display</code> property. This can cause significantly more images to be requested than you might be expecting and is another reason <code>&lt;picture&gt;</code> and <code>&lt;img srcset&gt;</code> are preferred for loading responsive images.</p>
<p>Have you ever written a media query that sets an image to <code>display:none</code> at certain breakpoints?</p>
<pre><code class="lang-html">&lt;img src=&quot;img.jpg&quot;&gt;
&lt;style&gt;
@media (max-width: 640px) {
    img {
        display: none;
    }
}
&lt;/style&gt;
</code></pre>
<p>Or toggled what images are hidden using a <code>display:none</code> class?</p>
<pre><code class="lang-html">&lt;style&gt;
.hidden {
  display: none;
}
&lt;/style&gt;
&lt;img src=&quot;img.jpg&quot;&gt;
&lt;img src=“img-hidden.jpg&quot; class=&quot;hidden&quot;&gt;
</code></pre>
<p>A quick check against the Chrome DevTools network panel will verify that images hidden using these approaches still get fetched, even when we expect them not to be. This behavior is actually correct per the embedded resources spec.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1503260160/essential-image-optimization/display-none-images.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1503260160/essential-image-optimization/display-none-images.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503260160/essential-image-optimization/display-none-images.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503260160/essential-image-optimization/display-none-images.jpg"
        alt="Images hidden with display:none still get fetched"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1503260160/essential-image-optimization/display-none-images.jpg"/>
</noscript>
</picture>
</figure>

<p><strong>Does <code>display:none</code> avoid triggering a request for an image <code>src</code>?</strong></p>
<pre><code class="lang-html">&lt;div style=&quot;display:none&quot;&gt;&lt;img src=&quot;img.jpg&quot;&gt;&lt;/div&gt;
</code></pre>
<p>No. The image specified will still get requested. A library cannot rely on display:none here as the image will be requested before JavaScript can alter the src.</p>
<p><strong>Does <code>display:none</code> avoid triggering a request for a <code>background: url()</code>?</strong></p>
<pre><code class="lang-html">&lt;div style=&quot;display:none&quot;&gt;
  &lt;div style=&quot;background: url(img.jpg)&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Yes. CSS backgrounds aren’t fetched as soon as an element is parsed. Calculating CSS styles for children of elements with <code>display:none</code> would be less useful as they don’t impact rendering of the document. Background images on child elements are not calculated nor downloaded.</p>
<p>Jake Archibald’s <a href="https://jakearchibald.github.io/request-quest/">Request Quest</a> has an excellent quiz on the pitfalls of using <code>display:none</code> for your responsive images loading. When in doubt about how specific browser’s handle image request loading, pop open their DevTools and verify for yourself.</p>
<p>Again, where possible, use <code>&lt;picture&gt;</code> and <code>&lt;img srcset&gt;</code> instead of relying on <code>display:none</code>.</p>
<h2 id="-a-id-image-processing-cdns-href-image-processing-cdns-does-an-image-processing-cdn-make-sense-for-you-a-"><a id="image-processing-cdns" href="#image-processing-cdns">Does an image processing CDN make sense for you?</a></h2>
<p><em>The time you’ll spend reading the blog posts to setup your own image processing pipeline and tweaking your config is often &gt;&gt; the fee for a service. With <a href="http://cloudinary.com/">Cloudinary</a> offering a free service, <a href="https://www.imgix.com/">Imgix</a> a free trial and <a href="https://github.com/thumbor/thumbor">Thumbor</a> existing as an OSS alternative, there are plenty of options available to you for automation.</em></p>
<p>To achieve optimal page load times, you need to optimize your image loading. This optimization calls for a responsive image strategy and can benefit from on-server image compression, auto-picking the best format and responsive resizing. What matters is that you deliver the correctly sized image to the proper device in the proper resolution as fast as possible. Doing this is not as easy as one might think.</p>
<p><strong>Using Your Server vs. a CDN</strong></p>
<p>Because of the complexity and ever-evolving nature of image manipulation, we’re going to offer a quote from someone with experience in the field, then proceed with a suggestion.</p>
<p>&quot;If your product is not image manipulation, then don’t do this yourself. Services like Cloudinary [or imgix, Ed.] do this much more efficiently and much better than you will, so use them. And if you’re worried about the cost, think about how much it’ll cost you in development and upkeep, as well as hosting, storage, and delivery costs.&quot; — <a href="https://medium.com/@cmgmyr/moving-from-self-hosted-image-service-to-cloudinary-bd7370317a0d">Chris Gmyr</a></p>
<p>For the moment, we are going to agree and suggest that you consider using a CDN for your image processing needs. Two CDNs will be examined to see how they compare relative to the list of tasks we raised earlier.</p>
<p><strong>Cloudinary and imgix</strong></p>
<p><a href="http://cloudinary.com/">Cloudinary</a> and <a href="https://www.imgix.com/">imgix</a> are two established image processing CDNs. They are the choice of hundreds of thousands of developers and companies worldwide, including Netflix and Red Bull. Let’s look at them in more detail.</p>
<p><strong>What are the Basics?</strong></p>
<p>Unless you are the owner of a network of servers like they are, their first huge advantage over rolling your own solution is that they use a distributed global network system to bring a copy of your images closer to your users. It’s also far easier for a CDN to ‘future proof’ your image loading strategy as trends change – doing this on your own requires maintenance, tracking browser support for emerging formats &amp; following the image compression community.</p>
<p>Second, each service has a tiered pricing plan, with Cloudinary offering a <a href="http://cloudinary.com/pricing">free level</a> and imgix pricing their standard level inexpensively, relative to their high-volume premium plan. Imgix offers a free <a href="https://www.imgix.com/pricing">trial</a> with a credit towards services, so it almost amounts to the same thing as a free level.</p>
<p>Third, API access is provided by both services. Developers can access the CDN programmatically and automate their processing. Client libraries, framework plugins, and API documentation are also available, with some features restricted to higher paid levels.</p>
<p><strong>Let’s Get to the Image Processing</strong></p>
<p>For now, let’s limit our discussion to static images. Both Cloudinary and Imgix offer a range of image manipulation methods, and both support primary functions such as compression, resizing, cropping and thumbnail creation in their standard and free plans.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1502426282/essential-image-optimization/Modern-Image36.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1502426282/essential-image-optimization/Modern-Image36.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image36.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image36.jpg"
        alt="cloudinary media library"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1502426282/essential-image-optimization/Modern-Image36.jpg"/>
</noscript>
</picture>
<figcaption>Cloudinary Media Library: By default Cloudinary encodes <a href="http://cloudinary.com/blog/progressive_jpegs_and_green_martians">non-Progressive JPEGs</a>. To opt-in to generating them, check the ‘Progressive’ option in ‘More options’ or pass the ‘fl_progressive’ flag.</figcaption>
</figure>

<p>Cloudinary lists <a href="http://cloudinary.com/documentation/image_transformations">seven broad image transformation</a> categories, with a total of 48 subcategories within them. Imgix advertises over <a href="https://docs.imgix.com/apis/url?_ga=2.52377449.1538976134.1501179780-2118608066.1501179780">100 image processing operations</a>.</p>
<p><strong>What Happens by Default?</strong></p>
<ul>
<li>Cloudinary performs the following optimizations by default:</li>
<li><a href="https://twitter.com/etportis/status/891529495336722432">Encodes JPEGs using MozJPEG</a> (opted against Guetzli as a default)</li>
<li>Strips all associated metadata from the transformed image file (the original image is left untouched). To override this behavior and deliver a transformed image with its metadata intact, add the keep_iptc flag.</li>
<li>Can generate WebP, GIF, JPEG, and JPEG-XR formats with automatic quality. To override the default adjustments, set the quality parameter in your transformation.</li>
<li>Runs <a href="http://cloudinary.com/documentation/image_optimization#default_optimizations">optimization</a> algorithms to minimize the file size with minimal impact to visual quality when generating images in the PNG, JPEG or GIF format.</li>
</ul>
<p>Imgix has no default optimizations such as Cloudinary has. It does have a settable default image quality. For imgix, auto parameters help you automate your baseline optimization level across your image catalog.</p>
<p>Currently, it has <a href="https://docs.imgix.com/apis/url/auto">four different methods</a>:</p>
<ul>
<li>Compression</li>
<li>Visual enhancement</li>
<li>File format conversion</li>
<li>Redeye removal</li>
</ul>
<p>Imgix supports the following image formats: JPEG, JPEG2000, PNG, GIF, Animated GIF, TIFF, BMP, ICNS, ICO, PDF, PCT, PSD, AI</p>
<p>Cloudinary supports the following image formats: JPEG, JPEG 2000, JPEG XR, PNG, GIF, Animated GIF, WebP, Animated WebP,BMPs, TIFF, ICOs, PDF, EPS, PSD, SVG, AI, DjVu, FLIF, TARGA.</p>
<p><strong>What About Performance?</strong></p>
<p>CDN delivery performance is mostly about <a href="https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDoxMzcyOWI1N2I4YzI3NzE2">latency</a> and speed.</p>
<p>Latency always increases somewhat for completely uncached images. But once an image is cached and distributed among the network servers, the fact that a global CDN can find the shortest hop to the user, added to the byte savings of a properly-processed image, almost always mitigates latency issues when compared to poorly processed images or solitary servers trying to reach across the planet.</p>
<p>Both services use fast and wide CDN. This configuration reduces latency and increases download speed. Download speed affects page load time, and this is one of the most important metrics for both user experience and conversion.</p>
<p><strong>So How Do They Compare?</strong></p>
<p>Cloudinary has <a href="http://cloudinary.com/customers">160K customers</a> including Netflix, eBay and Dropbox. Imgix doesn’t report how many customers it has, but it is smaller than Cloudinary. Even so, imgix’s base includes heavyweight image users such as Kickstarter, Exposure, unsplash, and Eventbrite.  </p>
<p>There are so many uncontrolled variables in image manipulation that a head-to-head performance comparison between the two services is difficult. So much depends on how much you need to process the image — which takes a variable amount of time — and what size and resolution are required for the final output, which affects speed and download time. Cost may ultimately be the most important factor for you.</p>
<p>CDNs cost money. An image heavy site with a lot of traffic could cost hundreds of US dollars a month in CDN fees. There is a certain level of prerequisite knowledge and programming skill required to get the most out of these services. If you are not doing anything too fancy, you’re probably not going to have any trouble.</p>
<p>But if you’re not comfortable working with image processing tools or APIs, then you are looking at a bit of a learning curve. In order to accommodate the CDN server locations, you will need to change some URLs in your local links. Do the right due diligence :)</p>
<p><strong>Conclusion</strong></p>
<p>If you are currently serving your own images or planning to, perhaps you should give a CDN some consideration.</p>
<h2 id="-a-id-caching-image-assets-href-caching-image-assets-caching-image-assets-a-"><a id="caching-image-assets" href="#caching-image-assets">Caching image assets</a></h2>
<p>Resources can specify a caching policy using <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#cache-control">HTTP cache headers</a>. Specifically, <code>Cache-Control</code> can define who can cache responses and for how long</p>
<p>Most of the images you deliver to users are static assets that will<a href="http://kean.github.io/post/image-caching"> not change</a> in the future. The best caching strategy for such assets is aggressive caching.</p>
<p>When setting your HTTP caching headers, set Cache-Control with a max-age of a year (e.g. <code>Cache-Control:public; max-age=31536000</code>). This type of aggressive caching works well for most types of images, especially those that are long-lived like avatars and image headers.</p>
<aside class="note"><b>Note:</b> If you’re serving images using PHP, it can destroy caching due to the default <a href="http://php.net/manual/en/function.session-cache-limiter.php">session_cache_limiter</a> setting. This can be a disaster for image caching and you may want to <a href="https://stackoverflow.com/a/3905468">work around</a> this by setting session_cache_limiter(&#39;public&#39;) which will set public, max-age=. Disabling and setting custom cache-control headers is also fine.</aside>

<h2 id="-a-id-preload-critical-image-assets-href-preload-critical-image-assets-preloading-critical-image-assets-a-"><a id="preload-critical-image-assets" href="#preload-critical-image-assets">Preloading critical image assets</a></h2>
<p>Critical image assets can be preloaded using <a href="https://www.w3.org/TR/preload/"><code>&lt;link rel=preload&gt;</code></a>.</p>
<p><code>&lt;link rel=preload&gt;</code> is a declarative fetch, allowing you to force the browser to make a request for a resource without blocking the document’s <code>onload</code> event. It enables increasing the priority of requests for resources that might otherwise not be discovered until later in the document parsing process.</p>
<p>Images can be preloaded by specifying an <code>as</code> value of <code>image</code>:</p>
<pre><code class="lang-html">&lt;link rel=&quot;preload&quot; as=&quot;image&quot; href=&quot;logo.jpg&quot;/&gt;
</code></pre>
<p>Image resources for <code>&lt;img&gt;</code>, <code>&lt;picture&gt;</code>, <code>srcset</code> and SVGs can all take advantage of this optimization.</p>
<aside class="note"><b>Note:</b> <code>&lt;link rel=&quot;preload&quot;&gt;</code> is <a href="http://caniuse.com/#search=preload">supported</a> in Chrome and Blink-based browsers like Opera, <a href="https://developer.apple.com/safari/technology-preview/release-notes/">Safari Tech Preview</a> and has been <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1222633">implemented</a> in Firefox.</aside>

<p>Sites like <a href="https://www.usa.philips.com/">Philips</a>, <a href="https://www.flipkart.com/">Flipkart</a> and <a href="https://www.xerox.com/">Xerox</a> use <code>&lt;link rel=preload&gt;</code> to preload their main logo assets (often used early in the document). <a href="https://kayak.com/">Kayak</a> also uses preload to ensure the hero image for their header is loaded as soon as possible.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504057647/essential-image-optimization/preload-philips.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1504057647/essential-image-optimization/preload-philips.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504057647/essential-image-optimization/preload-philips.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504057647/essential-image-optimization/preload-philips.jpg"
        alt="Philips use link rel=preload to preload their logo image"
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504057647/essential-image-optimization/preload-philips.jpg"/>
</noscript>
</picture>
</figure>

<p><strong>What is the Link preload header?</strong></p>
<p>A preload link can be specified using either an HTML tag or an <a href="https://www.w3.org/wiki/LinkHeader">HTTP Link header</a>. In either case, a preload link directs the browser to begin loading a resource into the memory cache, indicating that the page expects with high confidence to use the resource and doesn’t want to wait for the preload scanner or the parser to discover it.</p>
<p>A Link preload header for images would look similar to this:</p>
<pre><code>Link: &lt;https://example.com/logo-hires.jpg&gt;; rel=preload; as=image
</code></pre><p>When the Financial Times introduced a Link preload header to their site, they shaved <a href="https://twitter.com/wheresrhys/status/843252599902167040">1 second off</a> the time it took to display their masthead image:</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1504055773/essential-image-optimization/preload-financial-times.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1504055773/essential-image-optimization/preload-financial-times.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504055773/essential-image-optimization/preload-financial-times.jpg" />

<img
        class="lazyload"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504055773/essential-image-optimization/preload-financial-times.jpg"
        alt="The FT using preload. Displayed are the WebPageTest before and after traces showing improvements."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1504055773/essential-image-optimization/preload-financial-times.jpg"/>
</noscript>
</picture>
<figcaption>Bottom: with <code>&lt;link rel=preload&gt;</code>, Top: without. Comparison for a Moto G4 over 3G on WebPageTest both <a href="https://www.webpagetest.org/result/170319_Z2_GFR/">before</a> and <a href="https://www.webpagetest.org/result/170319_R8_G4Q/">after</a>.</figcaption>
</figure>

<p>Similarly, Wikipedia improved time-to-logo performance with the Link preload header as covered in their <a href="https://phabricator.wikimedia.org/phame/post/view/19/improving_time-to-logo_performance_with_preload_links/">case study</a>.</p>
<p><strong>What caveats should be considered when using this optimization?</strong></p>
<p>Be very certain that it’s worth preloading image assets as, if they aren’t critical to your user experience, there may be other content on the page worth focusing your efforts on loading earlier instead. By prioritizing image requests, you may end up pushing other resources further down the queue.</p>
<p>It’s important to avoid using <code>rel=preload</code> to preload image formats without broad browser support (e.g. WebP). It’s also good to avoid using it for responsive images defined in <code>srcset</code> where the retrieved source may vary based on device conditions.</p>
<p>To learn more about preloading, see <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">Preload, Prefetch and Priorities in Chrome</a> and <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/">Preload: What Is It Good For?</a>.</p>
<h2 id="-a-id-performance-budgets-href-performance-budgets-web-performance-budgets-for-images-a-"><a id="performance-budgets" href="#performance-budgets">Web Performance Budgets For Images</a></h2>
<p>A performance budget is a ‘budget’ for web page performance that a team attempts to not exceed. For example, ‘images will not exceed 200KB on any page’ or ‘the user experience must be usable in under 3 seconds’. When a budget isn’t being met, explore why this is and how you get back on target.</p>
<p>Budgets provide a useful framework for discussing performance with stakeholders. When a design or business decision may impact site performance, consult the budget. They’re a reference for pushing back or rethinking the change when it can harm a site’s user experience.</p>
<p>I’ve found teams have the best success with performance budgets when monitoring them is automated. Rather than manually inspecting network waterfalls for budget regressions, automation can flag when the budget is crossed. Two such services that are useful for performance budget tracking are <a href="https://calibreapp.com/docs/metrics/budgets">Calibre</a> and <a href="https://speedcurve.com/blog/tag/performance-budgets/">SpeedCurve</a>.</p>
<p>Once a performance budget for image sizes is defined, SpeedCurve starts monitoring and alerts you if the budget is exceeded:</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1505805372/essential-image-optimization/F2BCD61B-85C5-4E82-88CF-9E39CB75C9C0.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1505805372/essential-image-optimization/F2BCD61B-85C5-4E82-88CF-9E39CB75C9C0.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1505805372/essential-image-optimization/F2BCD61B-85C5-4E82-88CF-9E39CB75C9C0.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1505805372/essential-image-optimization/F2BCD61B-85C5-4E82-88CF-9E39CB75C9C0.jpg"
        alt="SpeedCurve image size monitoring."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1505805372/essential-image-optimization/F2BCD61B-85C5-4E82-88CF-9E39CB75C9C0.jpg"/>
</noscript>
</picture>
</figure>

<p>Calibre offers a similar feature with support for setting budgets for each device-class you’re targeting. This is useful as your budget for image sizes on desktop over WiFi may vary heavily to your budgets on mobile.</p>
<figure>
<picture>
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_500/v1505805371/essential-image-optimization/budgets.jpg"
        media="(max-width: 640px)" />
<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/c_scale,w_900/v1505805371/essential-image-optimization/budgets.jpg"
        media="(max-width: 1024px)" />

<source
        data-srcset="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1505805371/essential-image-optimization/budgets.jpg" />

<img
        class="lazyload small"
        data-src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1505805371/essential-image-optimization/budgets.jpg"
        alt="Calibre supports budgets for image sizes."
         />
<noscript>
  <img src="https://res.cloudinary.com/ddxwdqwkr/image/upload/v1505805371/essential-image-optimization/budgets.jpg"/>
</noscript>
</picture>
</figure>

<h2 id="-a-id-closing-recommendations-href-closing-recommendations-closing-recommendations-a-"><a id="closing-recommendations" href="#closing-recommendations">Closing recommendations</a></h2>
<p>Ultimately, choosing an image optimization strategy will come down to the types of images you’re serving down to your users and what you decide is a reasonable set of evaluation criteria. It might be using SSIM or Butteraugli or, if it’s a small enough set of images, going off of human perception for what makes the most sense.</p>
<p><strong>Here are my closing recommendations:</strong></p>
<p>If you <strong>can’t</strong> invest in conditionally serving formats based on browser support:</p>
<ul>
<li>Guetzli + MozJPEG’s jpegtran are good optimizers for JPEG quality &gt; 90.<ul>
<li>For the web <code>q=90</code> is wastefully high. You can get away with <code>q=80</code>, and on 2× displays even with <code>q=50</code>. Since Guetzli doesn’t go that low, for the web you can MozJPEG.</li>
<li>Kornel Lesi&#x144;ski recently improved mozjpeg’s cjpeg command to add tiny sRGB profile to help Chrome display natural color on wide-gamut displays</li>
</ul>
</li>
<li>PNG pngquant + advpng has a pretty good speed/compression ratio</li>
<li>If you <strong>can</strong> conditionally serve (using <code>&lt;picture&gt;</code>, the <a href="https://www.igvita.com/2013/05/01/deploying-webp-via-accept-content-negotiation/">Accept header</a> or <a href="https://scottjehl.github.io/picturefill/">Picturefill</a>):<ul>
<li>Serve WebP down to browsers that support it<ul>
<li>Create WebP images from original 100% quality images. Otherwise you’ll be giving browsers that do support it worse-looking images with JPEG distortions <em>and</em> WebP distortions! If you compress uncompressed source images using WebP it’ll have the less visible WebP distortions and can compress better too.</li>
<li>The default settings the WebP team use of <code>-m 4 -q 75</code> are usually good for most cases where they optimize for speed/ratio.</li>
<li>WebP also has a special mode for lossless (<code>-m 6 -q 100</code>) which can reduce a file to its smallest size by exploring all parameter combinations. It’s an order of magnitude slower but is worth it for static assets.</li>
</ul>
</li>
<li>As a fallback, serve Guetzli/MozJPEG compressed sources to other browsers</li>
</ul>
</li>
</ul>
<p>Happy compressing!</p>
<aside class="note"><b>Note:</b> For more practical guidance on how to optimize images, I heavily recommend <a href="https://www.manning.com/books/web-performance-in-action">Web Performance in Action</a> by Jeremy Wagner. <a href="http://shop.oreilly.com/product/0636920039730.do">High Performance Images</a> is also filled with excellent, nuanced advice on this topic.</aside>

<h2 id="-a-id-trivia-href-trivia-trivia-a-"><a id="trivia" href="#trivia">Trivia</a></h2>
<ul>
<li><a href="https://jpeg.org/jpegxt/">JPEG XT</a> defines extensions to the 1992 JPEG specification. For extensions to have pixel-perfect rendering on-top of old JPEG, the specification had to clarify the old 1992 spec and <a href="https://libjpeg-turbo.org/">libjpeg-turbo</a> was chosen as its reference implementation (based on popularity).</li>
<li><a href="https://github.com/google/pik">PIK</a> is a new image codec worth keeping an eye on. It’s compatible with JPEG, has a more efficient color-space and utilizes similar benefits found in Guetzli. It decodes at 2/3 the speed of JPEG and offers 54% more file savings than libjpeg does. It is both faster to decode and compress than Guetzli-ified JPEGs. A <a href="https://encode.ru/threads/2814-Psychovisual-analysis-on-modern-lossy-image-codecs">study</a> on psychovisual similarity of modern image codes showed PIK was less than half the size of alternatives. Unfortunately, it’s still early days for the codec and encoding is unusably slow at this time (August, 2017).</li>
<li><a href="https://www.imagemagick.org/script/index.php">ImageMagick</a> is often recommended for image optimization. This write-up considers it a fine tool, but its output generally requires more optimization and other tools can offer better output. We recommend trying <a href="https://github.com/jcupitt/libvips">libvips</a> instead, however it is lower-level and requires more technical skill to use. ImageMagick has also histortically had <a href="https://imagetragick.com/#moreinfo">noted</a> security vulnerabilities you may want to be aware of.</li>
<li>Blink (the rendering engine used by Chrome) decodes images off the main thread. Moving the decode work to the compositor thread frees-up the main thread to work on other tasks. We call this deferred decoding. With deferred decoding, the decode work remains on the critical path for presenting a frame to the display, so it can still cause animation jank. The <a href="https://html.spec.whatwg.org/multipage/embedded-content.html#dom-img-decode"><code>img.decode()</code></a> API should help with the jank problem.</li>
</ul>
<p class="license">The content of this book is licensed under the  Creative Commons <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">Attribution-NonCommercial-NoDerivs 2.0 Generic (CC BY-NC-ND 2.0)</a> license, and code samples are licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>. Copyright Google, 2017.</p>

<p></body>
</html></p>

    </div>
    <!-- build:js scripts/main.min.js -->
    <script src="scripts/main.js" async></script>
    <!-- endbuild -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-107163293-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
